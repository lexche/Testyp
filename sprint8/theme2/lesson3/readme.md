## Урок 3. Работа с MongoDB

В предыдущих уроках мы рассказали что такое нереляционные базы, рассказали как установить MongoDB и рассмотрели основные операции, в этом уроке расскажем про них более подробно через практику.

Представим, что у нас есть некая онлайн площадка, которая осуществляет подготовку по 4м направлениям: Квантовый кодинг, Астроинформатика, Технологии долголетия, Технологии устойчивого развития; для каждого направления есть свой проходной балл. У нас есть 10 студентов, которые сдали проверечные тестирования и уже имеют на руках свои баллы. Занесём эти данные в нашу БД, создав 2 коллекции: первая со студентами: порядковый номер, Имя, Фамилия, возраст, Оценка, вторая с факультетами: порядковый номер, Название, проходной балл.

Cоздадим базу:

```
use yp_db
```

Создадим в этой базе 2 коллекции: students и faculties, с помощью команд:

```
db.createCollection('students', {validator: {$jsonSchema: {bsonType: 'object',required: ['ID', 'firstName', 'lastName', 'age', 'gpa'],properties: {ID: { bsonType: 'number' },firstName: { bsonType: 'string' },lastName: { bsonType: 'string' },age: { bsonType: 'number' },gpa: { bsonType: 'number' }}}}});

db.createCollection('faculties', {validator: {$jsonSchema: {bsonType: 'object',required: ['ID', 'Faculty', 'gpa'],properties: {ID: { bsonType: 'number' },Faculty: { bsonType: 'string' },gpa: { bsonType: 'number' }}}}});

```

Разберём эти команды более детально, они создают коллекции students и faculties в базе данных MongoDB с определенной валидационной схемой JSON. Валидационная схема гарантирует, что все документы, вставляемые в коллекцию students, соответствуют определенной структуре и содержат необходимые поля. 

Валидационная схема JSON — это набор правил, которые определяют структуру и содержимое документов в коллекции MongoDB. Схемы JSON гарантируют, что данные в коллекции соответствуют определенным стандартам, что делает их более надежными и управляемыми.

Валидационные схемы JSON определяются в объекте $jsonSchema и могут включать следующие свойства:

• bsonType: Определяет тип документа или поля (например, объект, строка, число).

• required: Список обязательных полей.

• properties: Определяет типы данных и ограничения для вложенных полей.

• additionalProperties: Указывает, разрешены ли дополнительные свойства, не указанные в схеме.

• pattern: Регулярное выражение, которому должны соответствовать значения для данного поля.

• minimum, maximum: Указывает минимальное и максимальное значение для числовых полей.

• minLength, maxLength: Указывает минимальную и максимальную длину для строковых полей.

Рассмотрим части строки кода более подробно для коллекции students:

• db.createCollection('students'): Эта часть создает новую коллекцию с именем students в текущей базе данных.

• {validator: {$jsonSchema: ...}}: Эта часть определяет валидационную схему JSON для коллекции students. Валидационная схема указана в объекте $jsonSchema.

• {bsonType: 'object', required: ['ID', 'firstName', 'lastName', 'age', 'gpa'], properties: {...}}: Это сама валидационная схема JSON. Она определяет следующее:

- bsonType: 'object': Указывает, что документ должен быть объектом.

- required: ['ID', 'firstName', 'lastName', 'age', 'gpa']: Указывает, что поля ID, firstName, lastName, age и gpa являются обязательными для каждого документа в коллекции.

- properties: Определяет типы данных для каждого из обязательных полей:

        - ID: Должно быть числом (bsonType: 'number').

        - firstName: Должно быть строкой (bsonType: 'string').

        - lastName: Должно быть строкой (bsonType: 'string').

        - age: Должно быть числом (bsonType: 'number').

        - gpa: Должно быть числом (bsonType: 'number').

Таким образом, эта строка кода создает коллекцию students с валидационной схемой, которая требует, чтобы все документы имели определенную структуру и содержали обязательные поля ID, firstName, lastName, age и gpa с соответствующими типами данных, для коллекции faculties объяснение выше также подходит, отличие только в полях: ID, Faculty, gpa.

Внесём данные о факультетах в соответствующую коллекцию с помощью операции insert. Операция insert в MongoDB используется для вставки нового документа или нескольких документов в коллекцию. Метод insertOne используется для вставки одного документа в коллекцию, а insertMany вставляет несколько документов. Убедитесь, что документы соответствуют схеме коллекции перед вставкой.

Например:

```
db.collection_name.insertOne({ document })
```
document: Документ, который нужно вставить.

Внесём факультеты и их проходные балы в соответствующую коллекцию:

```
db.faculties.insertMany([ {ID: 1, Faculty: "Квантовый кодинг", gpa: 9 },{ ID: 2, Faculty: "Астроинформатика", gpa: 8 },{ID: 3, Faculty: "Технологии долголетия", gpa: 7 },{ ID: 4, Faculty: "Технологии устойчивого развития", gpa: 6 } ])
```

Сделаем то же самое со списком студентов:

```
db.createCollection('students', {validator: {$jsonSchema: {bsonType: 'object',required: ['ID', 'firstName', 'lastName', 'age', 'gpa'],properties: {ID: { bsonType: 'number' },firstName: { bsonType: 'string' },lastName: { bsonType: 'string' },age: { bsonType: 'number' },gpa: { bsonType: 'number' }}}}});
```

Посмотрим на то, что записалось в коллекцию, на примере коллекции students: 

```
db.students.find()
```

Вы увидите следующее:

```
 {
    _id: ObjectId('664e0811a6cafaa92fa26a26'),
    ID: 1,
    firstName: 'Ivan',
    lastName: 'Ivanov',
    age: 35,
    gpa: 7.8
  },
  {
    _id: ObjectId('664e0811a6cafaa92fa26a27'),
    ID: 2,
    firstName: 'Aleksandr',
    lastName: 'Aleksandrov',
    age: 26,
    gpa: 6.8
  },
  {
    _id: ObjectId('664e0811a6cafaa92fa26a28'),
    ID: 3,
    firstName: 'Marat',

        ....
```

Но что за значение _id? Мы же такого не вводили? 

Значение _id (идентификатор документа) - это специальное поле, которое автоматически создается и добавляется в каждый документ, вставленный в коллекцию MongoDB. Это уникальный идентификатор, который однозначно идентифицирует каждый документ в коллекции.

_id имеет следующие характеристики:

• Он уникален для каждого документа в коллекции.
• Он не может быть изменен или удален из документа.
• Он имеет тип данных ObjectId. ObjectId - это 12-байтовое значение, которое содержит:
    - 4 байта для инкрементного счетчика.
    - 3 байта для отметки времени.
    - 5 байт для случайного компонента.
• Он создается автоматически при вставке документа, если он не указан явно. Вы можете указать собственное значение _id при вставке документа, но оно должно быть уникальным.

_id играет важную роль в MongoDB:

• Он используется в качестве первичного ключа для коллекций.
• Он используется для индексации документов, что ускоряет запросы.
• Он используется для связывания документов между коллекциями с использованием внешних ключей.

Но такой вид неинформативен, давайте немного усовершенствуем запрос:

```
db.students.find({}, { _id: 0, firstName: 1, lastName: 1, gpa: 1 })
```

find(): Метод для поиска документов в коллекции. Первый аргумент - это фильтр запроса (в данном случае пустой объект {}, что означает, что будут возвращены все документы), а второй аргумент - это объект проекции.

{ _id: 0, firstName: 1, lastName: 1, gpa: 1 }: Объект проекции, который определяет, какие поля должны быть включены в результирующие документы. В данном случае:
    - _id: 0: Исключить поле _id из результатов. _id— единственное поле, которое необходимо явно исключить из проекции. Другие поля достаточно не включать в поиске, чтобы исключить их. Если не будет никаких условий кроме выключения _id, то выведутся все значения, кроме _id.

    - firstName: 1: Включить поле firstName.

    - lastName: 1: Включить поле lastName.

    - gpa: 1: Включить поле gpa.

Так более информативно:

```
[
  { firstName: 'Ivan', lastName: 'Ivanov', gpa: 7.8 },
  { firstName: 'Aleksandr', lastName: 'Aleksandrov', gpa: 6.8 },
  { firstName: 'Marat', lastName: 'Maratov', gpa: 8.2 },
  { firstName: 'Svetlana', lastName: 'Svetova', gpa: 9.1 },
  { firstName: 'Ignat', lastName: 'Ignatov', gpa: 6.4 },
  { firstName: 'Эмель', lastName: 'Емельянова', gpa: 7.4 },
  { firstName: 'Роберт', lastName: 'Робертов', gpa: 9.4 },
  { firstName: 'Marta', lastName: 'Apreleva', gpa: 6.1 },
  { firstName: 'Egor', lastName: 'Egorov', gpa: 8.3 },
  { firstName: 'Anna', lastName: 'Petrova', gpa: 5.9 }
]
```

Но давайте пойдём дальше и добавим сортировку по наивысшему баллу. Чтобы отсортировать коллекцию по высшему баллу в порядке возрастания (от 0 до 10), можно дополнить запрос конструкцией .sort({ gpa: 1 }), констукция .sort({ gpa: -1 }) будет сортировать в обратном порядке, при сортировке по имени 1 будет означать порядок от A до Z, -1 наоборот. Итоговый запрос будет иметь вид:

```

db.students.find({}, { _id: 0, ID: 1, firstName: 1, lastName: 1, gpa: 1 }).pretty({ full: true, shell: true, query: false }).sort({ gpa: 1 })

```

У нас маленькая база, поэтому запросы, которые сортируют данные на основе определенных полей практически не занимает времени. Но в больших базах подобные запросы могут занимать значительно больше времени. Для решения этой задачи в MongoDB используются индексы. 

Индекс в MongoDB - это структура данных, которая ускоряет выполнение запросов, особенно запросов, которые фильтруют или сортируют данные на основе определенных полей. Индексы организуют данные в коллекции таким образом, что база данных может быстро найти нужные документы без необходимости сканирования всей коллекции.

MongoDB хранит индексы в отдельной структуре данных, называемой B-деревом. B-дерево - это сбалансированное дерево, которое позволяет быстро искать данные по упорядоченному ключу. Когда запрос использует поле, по которому создан индекс, база данных может использовать индекс, чтобы быстро найти диапазон документов, соответствующих условию запроса.

Индексы улучшают производительность сортировки, но их создание и поддержание требуют дополнительных ресурсов. Поэтому важно тщательно продумать, какие индексы создавать, и избегать создания ненужных индексов.

Создадим индекс, чтобы закрепить полученные знания:

```
db.students.createIndex({ firstName: 1 })
```

Эта команда создает индекс по полю firstName в коллекции students. Индекс будет отсортирован в порядке возрастания значений поля firstName. Это означает, что база данных сможет быстро находить документы в коллекции, отсортированные по полю firstName, без необходимости сканирования всей коллекции.


---

Теперь поработаем с БД с помощью операций update.

Операция update в MongoDB используется для обновления существующих документов в коллекции.

Синтаксис:

db.collection_name.update({ filter }, { update })

Параметры:

• filter: Фильтр, который соответствует документам, которые нужно обновить.

• update: Оператор обновления, который определяет изменения, которые нужно внести в соответствующие документы.

Операторы обновления:

• $set: Заменяет существующие значения полей указанными значениями.

• $unset: Удаляет указанные поля из документа.

• $push: Добавляет значения в массив.

• $pull: Удаляет значения из массива.

• $inc: Увеличивает значение числового поля на указанное значение.

• $mul: Умножает значение числового поля на указанное значение.


Если внимательно рассмотреть выданные данные по коллекции students, то можно увидеть, что некоторые имена и фамилии написаны кириллицей. Обновим данные, переписав кириллицу в латиницу:

```
db.students.updateOne({ ID: 6 }, { $set: { firstName: 'Emel', lastName: 'Emelyanova' } })

db.students.updateOne({ ID: 7 }, { $set: { firstName: 'Robert', lastName: 'Robertov' } })

```
Давайте разберём первую строку: 

• db.students: Обращается к коллекции students в текущей базе данных.

• updateOne(): Метод для обновления одного документа, соответствующего указанному фильтру.

• ({ ID: 6 }): Фильтр, который соответствует документу со значением поля ID равным 6.

• ({ $set: { firstName: 'Emel', lastName: 'Emelyanova' } }): Оператор обновления - $set, который устанавливает значения полей firstName и lastName в указанные значения.

Теперь у нас все имена и фамилии на латинице.

Но давайте ещё немного поработаем с нашей базой.

Руководство онлайн платформы решили добавить ещё один курс: "Программирование на языке PsyDuck" с проходным балом 5. Добавим эту информацию в соответствующую коллекцию:

```
db.faculties.insertOne( {ID: 5, Faculty: "Программирование на языке PsyDuck", gpa: 5 } )

```

Внезапно поступила информация, что у Анны петровой проверочный тест на 1.5 балла выше. Исправим это в нашей таблице:

```
db.students.updateOne({ ID: 10 }, { $inc: { gpa: 1.5 } })

```
В этой строке мы именно увеличили уже имеющееся значение на 1.5 с помощью оператора $set

---

В mongosh, интерактивной оболочке MongoDB, есть две основные операции для удаления данных: delete и drop. Обе операции могут быть использованы для удаления документов из коллекции, но есть некоторые различия в их функциональности.

Операция delete используется для удаления одного или нескольких документов из коллекции, в соответствии с определенным критерием. Вот синтаксис delete:

db.collection.delete(<query>, <options>)


Где:
- <query>: это критерий выборки документов, которые нужно удалить.
- <options>: это опциональные параметры, такие как limit, который определяет максимальное количество документов для удаления.

Пример использования операции delete:

```
db.users.deleteOne({ name: "Anna" })
```

Этот код удалит один документ из коллекции users, где поле name равно "Anna".

Операция drop используется для удаления всей коллекции. Синтаксис drop:

db.collection.drop()

Для удаления базы данных целиком в MongoDB Shell используется метод dropDatabase().

Пример удаления базы данных mydatabase:

use mydatabase
db.dropDatabase()


Помните, что операция db.dropDatabase() удаляет все данные из базы данных mydatabase, включая все коллекции из этой базы данных.

Выполняйте удаление баз данных и коллекций с осторожностью, так как все данные будут безвозвратно утеряны. Предварительно убедитесь, что вы действительно хотите удалить данные, и возможно, сделайте резервную копию перед удалением.

### Практическое задание

Создайте БД, которую мы рассматривали в примере выше. В результате у вас должна получиться БД с двумя коллекциями: 10 студентов и 5 курсов.

---

Во второй части урока расскажем про использование агрегационного пайплайна MongoDB.

Агрегационный пайплайн в MongoDB - это механизм для выполнения операций агрегации данных (например, суммирование, сортировка, группировка и т.д.) в коллекциях MongoDB. Пайплайн агрегации представляет собой последовательность операций обработки данных, которые применяются к документам в коллекции.

Пайплайн агрегации состоит из различных этапов, каждый из которых выполняет определенную операцию или преобразование над данными. Этапы пайплайна выполняются последовательно, и каждый последующий этап использует результаты предыдущего этапа.

Примеры операций, которые можно выполнять с помощью агрегационного пайплайна в MongoDB, включают:

1. Фильтрация данных
2. Группировка данных
3. Преобразование данных
4. Сортировка данных
5. Уникализация данных
6. Вычисление агрегатных функций (например, среднее, сумма, минимум, максимум и т.д.)

Рассмотрим основнае опператоры:

1. $match: Фильтрация документов по определенному критерию. 

```
db.users.aggregate([
  {
    $match: {
      age: { $gt: 30 }
    }
  }
])
```

Этот пример выбирает все документы из коллекции `users`, где поле `age` больше 30

2. $group: Группировка документов по определенному полю и применение агрегационных функций к данным в каждой группе. 

```
db.orders.aggregate([
  {
    $group: {
      _id: "$product_category",
      total_sales: { $sum: "$price" }
    }
  }
])
```

Этот пример группирует документы в коллекции `orders` по полю `product_category` и вычисляет общую сумму продаж для каждой категории.

3. $project: Выборка определенных полей из документов и переименование или создание новых полей. 

```
db.users.aggregate([
  {
    $project: {
      name: 1,
      _id: 0
    }
  }
])
```

Этот пример проецирует коллекцию `users`, включая только поля `name` и исключая поле `_id`.

4. $sort: Сортировка документов в результате агрегации по определенному полю. 

```
db.products.aggregate([
  {
    $sort: {
      price: -1
    }
  }
])
```

Этот пример сортирует коллекцию `products` в порядке убывания по полю `price`.

5. $facet: Позволяет выполнять несколько агрегационных операций параллельно и объединять их результаты. 

```
db.orders.aggregate([
  {
    $facet: {
      total_sales: [
        { $group: { _id: null, total_sales: { $sum: "$price" } } }
      ],
      average_sales: [
        { $group: { _id: null, average_sales: { $avg: "$price" } } }
      ]
    }
  }
])
```

Этот пример использует `$facet` для создания двух "фасетов": `total_sales` и `average_sales`. Каждый фасет выполняет отдельный конвейер на одних и тех же входных данных.

6. $unwind: Разбивает массивные поля документа на отдельные документы, что упрощает их обработку в пайплайне. 

```
db.students.aggregate([
  {
    $unwind: "$hobbies"
  }
])
```

 Этот пример разворачивает массив `hobbies` в коллекции `students` в отдельные документы

7. $lookup: Выполняет операцию объединения (join) с другой коллекцией MongoDB. 

```
db.orders.aggregate([
  {
    $lookup: {
      from: "products",
      localField: "product_id",
      foreignField: "_id",
      as: "product_details"
    }
  }
])
```

Этот пример объединяет коллекцию `orders` с коллекцией `products` на основе поля `product_id` и добавляет объединенные данные в новый массив `product_details`.

8. $addFields: Добавляет новое поле или обновляет существующее в документе. 

```
db.users.aggregate([
  {
    $addFields: {
      full_name: { $concat: ["$first_name", " ", "$last_name"] }
    }
  }
])
```

Этот пример добавляет новое поле `full_name` в коллекцию `users`, которое объединяет поля `first_name` и `last_name`.

9. $redact: Применяет правила доступа к данным на уровне документов. 
```
db.users.aggregate([
  {
    $redact: {
      $cond: {
        if: { $gte: ["$age", 18] },
        then: "$$KEEP",
        else: "$$PRUNE"
      }
    }
  }
])
```

Этот пример скрывает документы из коллекции `users`, где поле `age` меньше 18.

Перейдём к примерам.

1. Давайте представим, что у нас есть две коллекции: "users" и "posts". Коллекция "users" содержит информацию о пользователях, включая их имя, возраст и ID, а коллекция "posts" содержит посты, которые пользователи опубликовали, включая текст поста, ID пользователя, дату публикации и количество лайков.

Мы хотим выбрать все посты, написанные пользователями старше 30 лет и у которых количество лайков больше 100. Результат запроса мы хотим записать в новую коллекцию "popular_posts".

Пример запроса в mongosh:

```
db.users.aggregate([
  {
    $lookup: {
      from: "posts",
      localField: "userId",
      foreignField: "userId",
      as: "userPosts"
    }
  },
  {
    $match: {
      $and: [
        { age: { $gt: 30 } },
        { "userPosts.likes": { $gt: 100 } }
      ]
    }
  },
  {
    $out: "popular_posts"
  }
])
```

В данном примере мы используем `$lookup` для объединения коллекций "users" и "posts" по полю "userId". Затем с помощью `$match` мы фильтруем пользователей старше 30 лет и посты с количеством лайков больше 100. Наконец, с помощью `$out` результаты агрегации записываются в новую коллекцию "popular_posts".

Таким образом, мы создаем новую коллекцию, содержащую только посты, написанные пользователями старше 30 лет и с количеством лайков больше 100.

2. У нас есть две коллекции: "authors" и "books". Коллекция "authors" содержит информацию об авторах книг, включая их имя, страну и возраст, а коллекция "books" содержит информацию о книгах, включая название книги, жанр и ID автора.

Мы хотим соединить данные из обеих коллекций, выбрать книги, написанные авторами старше 40 лет в жанре "фэнтези" и создать новую коллекцию "fantasy_books_over_40".

Пример запроса в mongosh:

```javascript
db.authors.aggregate([
  {
    $lookup: {
      from: "books",
      localField: "_id",
      foreignField: "authorId",
      as: "author_books"
    }
  },
  {
    $unwind: "$author_books"
  },
  {
    $addFields: {
      author_age: {
        $subtract: [2022, "$age"]
      }
    }
  },
  {
    $facet: {
      fantasy_books: [
        {
          $match: {
            "author_age": { $gt: 40 },
            "author_books.genre": "fantasy"
          }
        }
      ]
    }
  },
  {
    $unwind: "$fantasy_books"
  },
  {
    $out: "fantasy_books_over_40"
  }
])
```

В этом запросе мы используем оператор `$lookup`, чтобы объединить данные из коллекции "books" с данными из коллекции "authors" на основе совпадения ID автора. Затем мы используем оператор `$unwind`, чтобы развернуть массив "author_books" и оператор `$addFields`, чтобы вычислить возраст автора.

Затем мы используем оператор `$facet`, чтобы создать несколько этапов агрегации. Мы выбираем книги, написанные авторами старше 40 лет в жанре "фэнтези", после чего результат записывается в новую коллекцию "fantasy_books_over_40".

3. Поработаем с нашей БД. У нас есть 5 факультетов и 10 студентов. Создадим новую коллекцию Score, в неё мы запишем на какой из курсов поступили студенты при условии, что каждый студент хочет попасть на факультет с наивысшим балом, на каждом факультете есть 2 места.

Создаём коллекцию "Score":

```
db.createCollection("Score");
```

Следующим действием, решаем поставленную задачу:

```
db.students.find().sort({ gpa: -1 }).forEach(student => {
    let availableFaculty = db.faculties.findOne({ studentCount: { $lt: 2 }, gpa: { $lte: student.gpa }, "admittedStudents": { $nin: [student.lastName] } });
    if (availableFaculty) {
        db.faculties.updateOne({ _id: availableFaculty._id }, {
            $inc: { studentCount: 1 },
            $push: { admittedStudents: student.lastName }
        });
        db.Score.insertOne({
            "lastName": student.lastName,
            "gpa": student.gpa,
            "faculty": availableFaculty.Faculty
        });
    } else {
        print(`Студент ${student.lastName} не был зачислен ни на один факультет.`);
    }
});
```

Хоть решение и очевидно, мы позволим себе дать комментарии того, что произошло:

1. db.students.find().sort({ gpa: -1 }).forEach(student => { - Здесь мы ищем всех студентов в коллекции "students", сортируем их по убыванию среднего балла (GPA) и для каждого студента выполняем следующий код.

2. let availableFaculty = db.faculties.findOne({ studentCount: { $lt: 2 }, gpa: { $lte: student.gpa }, "admittedStudents": { $nin: [student.lastName] } }); - Мы ищем факультет, который удовлетворяет следующим условиям: количество студентов на факультете меньше двух, средний балл GPA на факультете не превышает GPA текущего студента, и текущий студент еще не был зачислен на этот факультет.

3. if (availableFaculty) { - Если нашли подходящий факультет для студента, выполняем следующий код.

4. db.faculties.updateOne({ _id: availableFaculty._id }, { $inc: { studentCount: 1 }, $push: { admittedStudents: student.lastName } }); - Увеличиваем количество студентов на факультете на 1 и добавляем фамилию текущего студента в список зачисленных на этот факультет.

5. db.Score.insertOne({ "lastName": student.lastName, "gpa": student.gpa, "faculty": availableFaculty.Faculty }); - Записываем информацию о студенте (фамилия, средний балл, факультет) в коллекцию "Score".

6. else { print(Студент ${student.lastName} не был зачислен ни на один факультет.); } - Если не удалось найти подходящий факультет для студента, выводим сообщение о том, что студент не был зачислен ни на один факультет.


### Практическое задание.

Возьмите 3й пример из второй части урока, "напильник" и немного его доработайте: дайте более полную информацию о студенте, помимо фамилии добавьте имя и возраст. Создайте для каждого факультета коллекцию с поступившими студентами на основе коллекции Score.

---


В этом уроке мы плотно поработали в mongosh, кроме того проработали и закрепили CRUD-операции, узнали что такое валидационная схема JSON, агрегационный пайплайн в MongoDB, где и как они используются разобрали примеры использования.
