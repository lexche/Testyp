## Урок 3. Работа с MongoDB

В предыдущих уроках мы рассказали что такое нереляционные базы, рассказали как установить MongoDB и рассмотрели основные операции, в этом уроке расскажем про них более подробно через практику.

Представим, что у нас есть некая онлайн площадка, которая осуществляет подготовку по 4м направлениям: Квантовый кодинг, Астроинформатика, Технологии долголетия, Технологии устойчивого развития; для каждого направления есть свой проходной балл. У нас есть 10 студентов, которые сдали проверечные тестирования и уже имеют на руках свои баллы. Занесём эти данные в нашу БД, создав 2 коллекции: первая со студентами: порядковый номер, Имя, Фамилия, возраст, Оценка, вторая с факультетами: порядковый номер, Название, проходной балл.

Cоздадим базу:

```
use yp_db
```

Создадим в этой базе 2 коллекции: students и faculties, с помощью команд:

```
db.createCollection('students', {validator: {$jsonSchema: {bsonType: 'object',required: ['ID', 'firstName', 'lastName', 'age', 'gpa'],properties: {ID: { bsonType: 'number' },firstName: { bsonType: 'string' },lastName: { bsonType: 'string' },age: { bsonType: 'number' },gpa: { bsonType: 'number' }}}}});

db.createCollection('faculties', {validator: {$jsonSchema: {bsonType: 'object',required: ['ID', 'Faculty', 'PS'],properties: {ID: { bsonType: 'number' },Faculty: { bsonType: 'string' },PS: { bsonType: 'number' }}}}});

```

Разберём эти команды более детально, они создают коллекции students и faculties в базе данных MongoDB с определенной валидационной схемой JSON. Валидационная схема гарантирует, что все документы, вставляемые в коллекцию students, соответствуют определенной структуре и содержат необходимые поля. 

Валидационная схема JSON — это набор правил, которые определяют структуру и содержимое документов в коллекции MongoDB. Схемы JSON гарантируют, что данные в коллекции соответствуют определенным стандартам, что делает их более надежными и управляемыми.

Валидационные схемы JSON определяются в объекте $jsonSchema и могут включать следующие свойства:

• bsonType: Определяет тип документа или поля (например, объект, строка, число).

• required: Список обязательных полей.

• properties: Определяет типы данных и ограничения для вложенных полей.

• additionalProperties: Указывает, разрешены ли дополнительные свойства, не указанные в схеме.

• pattern: Регулярное выражение, которому должны соответствовать значения для данного поля.

• minimum, maximum: Указывает минимальное и максимальное значение для числовых полей.

• minLength, maxLength: Указывает минимальную и максимальную длину для строковых полей.

Рассмотрим части строки кода более подробно для коллекции students:

• db.createCollection('students'): Эта часть создает новую коллекцию с именем students в текущей базе данных.

• {validator: {$jsonSchema: ...}}: Эта часть определяет валидационную схему JSON для коллекции students. Валидационная схема указана в объекте $jsonSchema.

• {bsonType: 'object', required: ['ID', 'firstName', 'lastName', 'age', 'gpa'], properties: {...}}: Это сама валидационная схема JSON. Она определяет следующее:

- bsonType: 'object': Указывает, что документ должен быть объектом.

- required: ['ID', 'firstName', 'lastName', 'age', 'gpa']: Указывает, что поля ID, firstName, lastName, age и gpa являются обязательными для каждого документа в коллекции.

- properties: Определяет типы данных для каждого из обязательных полей:

        - ID: Должно быть числом (bsonType: 'number').

        - firstName: Должно быть строкой (bsonType: 'string').

        - lastName: Должно быть строкой (bsonType: 'string').

        - age: Должно быть числом (bsonType: 'number').

        - gpa: Должно быть числом (bsonType: 'number').

Таким образом, эта строка кода создает коллекцию students с валидационной схемой, которая требует, чтобы все документы имели определенную структуру и содержали обязательные поля ID, firstName, lastName, age и gpa с соответствующими типами данных, для коллекции faculties объяснение выше также подходит, отличие только в полях: ID, Faculty, PS.

Внесём данные о факультетах в соответствующую коллекцию:

```
db.faculties.insertMany([ {ID: 1, Faculty: "Квантовый кодинг", PS: 9 },{ ID: 2, Faculty: "Астроинформатика", PS: 8 },{ID: 3, Faculty: "Технологии долголетия", PS: 7 },{ ID: 4, Faculty: "Технологии устойчивого развития", PS: 6 } ])
```

Этой командой мы записываем факультеты и их проходные балы в соответствующую коллекцию. Сделаем то же самое со списком студентов:

```
db.createCollection('students', {validator: {$jsonSchema: {bsonType: 'object',required: ['ID', 'firstName', 'lastName', 'age', 'gpa'],properties: {ID: { bsonType: 'number' },firstName: { bsonType: 'string' },lastName: { bsonType: 'string' },age: { bsonType: 'number' },gpa: { bsonType: 'number' }}}}});
```

Посмотрим на то, что записалось в коллекцию: 

```
db.students.find()
```

Вы увидите следующее:

```
 {
    _id: ObjectId('664e0811a6cafaa92fa26a26'),
    ID: 1,
    firstName: 'Ivan',
    lastName: 'Ivanov',
    age: 35,
    gpa: 7.8
  },
  {
    _id: ObjectId('664e0811a6cafaa92fa26a27'),
    ID: 2,
    firstName: 'Aleksandr',
    lastName: 'Aleksandrov',
    age: 26,
    gpa: 6.8
  },
  {
    _id: ObjectId('664e0811a6cafaa92fa26a28'),
    ID: 3,
    firstName: 'Marat',

        ....
```

Но что за значение _id? Мы же такого не вводили? 

Значение _id (идентификатор документа) - это специальное поле, которое автоматически создается и добавляется в каждый документ, вставленный в коллекцию MongoDB. Это уникальный идентификатор, который однозначно идентифицирует каждый документ в коллекции.

_id имеет следующие характеристики:

• Он уникален для каждого документа в коллекции.
• Он не может быть изменен или удален из документа.
• Он имеет тип данных ObjectId. ObjectId - это 12-байтовое значение, которое содержит:
    - 4 байта для инкрементного счетчика.
    - 3 байта для отметки времени.
    - 5 байт для случайного компонента.
• Он создается автоматически при вставке документа, если он не указан явно. Вы можете указать собственное значение _id при вставке документа, но оно должно быть уникальным.

_id играет важную роль в MongoDB:

• Он используется в качестве первичного ключа для коллекций.
• Он используется для индексации документов, что ускоряет запросы.
• Он используется для связывания документов между коллекциями с использованием внешних ключей.

Но такой вид неинформативен, давайте немного усовершенствуем запрос:

```
db.students.find({}, { _id: 0, firstName: 1, lastName: 1, gpa: 1 })
```

find(): Метод для поиска документов в коллекции. Первый аргумент - это фильтр запроса (в данном случае пустой объект {}, что означает, что будут возвращены все документы), а второй аргумент - это объект проекции.

{ _id: 0, firstName: 1, lastName: 1, gpa: 1 }: Объект проекции, который определяет, какие поля должны быть включены в результирующие документы. В данном случае:
    - _id: 0: Исключить поле _id из результатов. _id— единственное поле, которое необходимо явно исключить из проекции. Другие поля достаточно не включать в поиске, чтобы исключить их. Если не будет никаких условий кроме выключения _id, то выведутся все значения, кроме _id.

    - firstName: 1: Включить поле firstName.

    - lastName: 1: Включить поле lastName.

    - gpa: 1: Включить поле gpa.

Так более информативно:

```
[
  { firstName: 'Ivan', lastName: 'Ivanov', gpa: 7.8 },
  { firstName: 'Aleksandr', lastName: 'Aleksandrov', gpa: 6.8 },
  { firstName: 'Marat', lastName: 'Maratov', gpa: 8.2 },
  { firstName: 'Svetlana', lastName: 'Svetova', gpa: 9.1 },
  { firstName: 'Ignat', lastName: 'Ignatov', gpa: 6.4 },
  { firstName: 'Эмель', lastName: 'Емельянова', gpa: 7.4 },
  { firstName: 'Роберт', lastName: 'Робертов', gpa: 9.4 },
  { firstName: 'Marta', lastName: 'Apreleva', gpa: 6.1 },
  { firstName: 'Egor', lastName: 'Egorov', gpa: 8.3 },
  { firstName: 'Anna', lastName: 'Petrova', gpa: 5.9 }
]
```

Но давайте пойдём дальше и добавим сортировку по наивысшему баллу. Чтобы отсортировать коллекцию по высшему баллу в порядке возрастания (от 0 до 10), можно дополнить запрос конструкцией .sort({ gpa: 1 }), констукция .sort({ gpa: -1 }) будет сортировать в обратном порядке, при сортировке по имени 1 будет означать порядок от A до Z, -1 наоборот. Итоговый запрос будет иметь вид:

```

db.students.find({}, { _id: 0, ID: 1, firstName: 1, lastName: 1, gpa: 1 }).pretty({ full: true, shell: true, query: false }).sort({ gpa: 1 })

```

У нас маленькая база, поэтому запросы, которые сортируют данные на основе определенных полей практически не занимает времени. Но в больших базах подобные запросы могут занимать значительно больше времени. Для решения этой задачи в MongoDB используются индексы. 

Индекс в MongoDB - это структура данных, которая ускоряет выполнение запросов, особенно запросов, которые фильтруют или сортируют данные на основе определенных полей. Индексы организуют данные в коллекции таким образом, что база данных может быстро найти нужные документы без необходимости сканирования всей коллекции.

MongoDB хранит индексы в отдельной структуре данных, называемой B-деревом. B-дерево - это сбалансированное дерево, которое позволяет быстро искать данные по упорядоченному ключу. Когда запрос использует поле, по которому создан индекс, база данных может использовать индекс, чтобы быстро найти диапазон документов, соответствующих условию запроса.

Индексы улучшают производительность сортировки, но их создание и поддержание требуют дополнительных ресурсов. Поэтому важно тщательно продумать, какие индексы создавать, и избегать создания ненужных индексов.

Создадим индекс, чтобы закрепить полученные знания:

```
db.students.createIndex({ firstName: 1 })
```

Эта команда создает индекс по полю firstName в коллекции students. Индекс будет отсортирован в порядке возрастания значений поля firstName. Это означает, что база данных сможет быстро находить документы в коллекции, отсортированные по полю firstName, без необходимости сканирования всей коллекции.

