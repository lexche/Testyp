## Урок 4: Запуск и управление контейнерами

В прошлом уроке мы разобрались как создавать Docker образы с помощью Dockerfile. В этом уроке узнаем, что с этими образами можно делать после создания. 

Начнём с того, что Dockerfile - это необязательное условие для запуска контейнера. Dockerfile нужен для задания необходимых настроек будущему образу. Но если нас устраивает дефолтный образ и минимальный набор параметров, то можно обойтись и без него, добавив эти параметры сразу в командную строку.

Преимущества использование Dockerfile:

- **Гибкость**: Использование Dockerfile позволяет тебе создавать образы, которые соответствуют твоим уникальным требованиям, включая установку программного обеспечения, переменных среды, копирование файлов и многое другое.

- **Воспроизводимость**: С использованием Dockerfile ты можешь документировать процесс сборки образа, что обеспечивает воспроизводимость и понимание того, что включено в образ.

- **Управление версиями**: Dockerfile позволяет тебе легко управлять версиями образов и изменениями, вносимыми в них, что сделает процесс обновления и отката более простым.

Таким образом, использование Dockerfile дает большую гибкость и контроль над процессом создания образов, тогда как запуск контейнера без Dockerfile удобен для быстрого прототипирования и тестирования существующих образов.

Для запуска образа контейнера используется команда ```docker run```. Команда docker run имеет много различных флагов, которые позволяют настраивать поведение контейнера при его запуске:

- -d (detach): Этот флаг позволяет запустить контейнер в фоновом режиме, так что он не будет привязан к текущему терминалу.
  
- -it (interactive, terminal): Этот флаг запускает контейнер в интерактивном режиме, разрешая взаимодействие с терминалом. Он устанавливает интерактивный режим ( -i ) и ассоциирует его с твоим терминалом ( -t ).
  
- --name (название контейнера): Позволяет задать имя контейнера вместо генерируемого по умолчанию, что облегчает его идентификацию.

- --network (сеть): Позволяет подключить контейнер к определенной сети.

- --rm (remove): После завершения работы контейнера он будет автоматически удален.

- -w (--workdir) : Устанавливает текущую рабочую директорию внутри контейнера.

- -p (публикация портов): Позволяет пробросить порты контейнера на порты хоста.

- --env (переменные среды): Позволяет устанавливать переменные среды внутри контейнера.
  
- --network: Позволяет присоединить контейнер к определенной сети.

- -v (--volume):  Позволяет подключить внешнее хранилище (например, том или директорию хоста) к контейнеру при его запуске.

  Рассмотрим несколько примеров с объяснениями:

1. Простой пример запуска контейнера в интерактивном режиме:
   ```bash
   $ docker run -it ubuntu
   ```
   Эта команда запустит контейнер на основе образа Ubuntu в интерактивном режиме, что позволит взаимодействовать с командной строкой внутри контейнера.

2. Запуск контейнера в фоновом режиме, определение имени и проброс портов:
   ```bash
   $ docker run -d --name my_container -p 8085:80 nginx
   ```
   В этом примере мы запускаем контейнер на основе образа NGINX в фоновом режиме, присваиваем ему имя "my_container" и пробрасываем порт 80 контейнера на порт 8080 хоста.

3. Запуск контейнера с использованием пользовательских переменных среды:
   ```bash
   $ docker run --env MYSQL_ROOT_PASSWORD=pass123 --env MYSQL_DATABASE=mydb mysql
   ```
   В этом примере мы запускаем контейнер на основе образа MySQL, устанавливаем переменную среды MYSQL_ROOT_PASSWORD и MYSQL_DATABASE для настройки базы данных MySQL внутри контейнера.

 4. Подключение контейнера к сети с именем "Some_net", можно использовать следующую команду:

    ```bash
     $ docker run --network=Some_net ubuntu
    ```

5.  Запуск контейнера с подключением локальной директорией "/home/user1/somefolder" к контейнеру по пути "/data" можно использовать следующую команду:
   
    ```bash
      docker run --volume=/home/user1/somefolder:/data ubuntu
    ```
    
Помимо ``` docker run ``` существуют и другие команды с помощью которых можно взаимодействовать с контейнером, например:

- Docker Copy, он же ``` docker cp```.

  Команда ``` docker cp ``` позволяет копировать файлы между хостом и контейнером или между контейнерами. Это полезно, когда тебе нужно скопировать файлы или данные внутрь контейнера или из контейнера на хост.

  Пример:

  ```bash
  docker cp /local/some.txt super_container:/opt/some.txt
  ```

Эта команда скопирует файл "some.txt" с хоста внутрь контейнера "super_container" в директорию "/opt".

- Docker Exec.
  
  Команда docker exec используется для выполнения команд внутри запущенного контейнера. Это позволяет запускать дополнительные процессы или выполнять административные задачи в контейнере.

  Пример:

  ```
  docker exec some_mysql_container mysql -uroot -p -e 'CREATE DATABASE new_database;'
  ```
  
 В данном случае, мы выполняем команду MySQL для создания новой базы данных в контейнере ```some_mysql_container```.

### Практическое задание

Ниже представлены Dockerfiles и варианты как их можно представить в виде команды. Найдите правильный вариант.


```
FROM node:14


WORKDIR /usr/src/app


COPY package*.json ./


RUN npm install


COPY . .

CMD ["npm", "start"]
```

1. ```bash
   docker run -it --volume "$(pwd):/usr/src/app" -w /usr/src/app_1 node:14 npm start
   ```

2. ```bash
   docker build --volume "$(pwd):/usr/src/app" -w /usr/src/app node:14 npm start
   ```

3. ```bash
   docker run -it --volume "$PWD:/usr/src/app" -w /usr/src/app node:latest npm start
   ```

4.  ```bash
    docker run -it --workdir="/usr/src/app" -v "$(pwd):/usr/src/app" node:14 npm start
   ```
   
Правильный ответ - 4, разберем эту команду:

- docker run - запускает новый контейнер
- -it - предоставляет интерактивную оболочку TTY
- --workdir="/usr/src/app" - устанавливает рабочую директорию в контейнере в /usr/src/app
- -v "$(pwd):/usr/src/app" - монтирует текущую рабочую директорию хоста внутри контейнера по пути /usr/src/app
- node:14 - имя образа, который мы хотим запустить
- npm start - команда, которую мы хотим выполнить внутри контейнера

Таким образом, данная команда docker run будет создавать контейнер из образа Node.js и запускать команду npm start из рабочей директории /usr/src/app.
```
---
```
FROM node:14

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

1. docker run -p 3000:3000 -w /usr/src/app -d node:14 npm start
   - Этот вариант пропускает монтирование текущей директории хоста в контейнер, что приведет к тому, что контейнер не увидит исходный код приложения.

2. docker run -p 3000:3000 -v $(pwd):/usr/src/app -w /usr/src/app -d node:14 npm start

3. docker run -p 3000:3000 -v $(pwd):/usr/src/app -d node:14 npm build
   - В данном варианте указана неверная команда для сборки приложения.

4. docker run -p 3000:3000 -v $(pwd):/usr/src/app -w /usr/src/app -d node:14
   - В этом варианте пропущена конечная команда для запуска приложения.


Правильный ответ 2, разберем эту команду:

- -p 3000:3000 - пробрасывает порт 3000 из контейнера на порт 3000 хоста
- -v $(pwd):/usr/src/app - монтирует текущую директорию хоста внутри контейнера
- -w /usr/src/app - задает рабочую директорию в контейнере
- -d - запускает контейнер в фоновом режиме
- node:14 - имя образа, который мы хотим запустить
- npm start - команда для запуска приложения

---

Создавать образы, запускать их и выполнять внутри контейнеров команды - это далеко не всё для чего предназначен Docker. А именно:


1. docker create
   
   Команда docker create создает новый контейнер, но не запускает его. Это позволяет подготовить контейнер для запуска, но не начинать его выполнение до явной команды docker start.

   Пример: docker create -it --name=my_container ubuntu:latest bash Создает новый контейнер из образа ubuntu:latest с оболочкой bash, именем контейнера "my_container" и войдет в интерактивный режим для взаимодействия с оболочкой.

 2. docker ps
     
  Эта команда отображает запущенные контейнеры.
  Пример: docker ps - выводит список запущенных контейнеров с их ID, именами, статусом и другой информацией.

    Флаги:
      -a  Отображает все контейнеры, включая остановленные.
      -q  Показывает только идентификаторы контейнеров.

  3. docker images
     
    Команда docker images отображает список доступных образов на вашем компьютере.
    Пример: docker images - выводит список всех образов в вашем локальном репозитории Docker.

     Флаги:
      -a  Отображает все образы, включая промежуточные.
     
  4. docker stop
     
      Останавливает работу запущенного контейнера.
     
      Пример: docker stop my_container - останавливает контейнер с именем "my_container".

5.  docker kill
      
   Команда docker kill  отправляет сигнал остановки внутрь контейнера. Это полезно, если контейнер не реагирует на команду docker stop или если необходимо немедленно остановить контейнер.

   Пример: docker kill my_container -  отправляет сигнал  контейнеру с именем my_container, что немедленно останавливает его выполнение. 

  
  6. docker rm
   
     Удаляет контейнеры.
     Пример: docker rm my_container - удаляет контейнер с именем my_container.

      Флаги:
     
       -f  Удаляет контейнеры принудительно (независимо от их состояния).

  7. docker rmi
    
       Удаляет образы Docker.
       Пример: docker rmi my_image - удаляет образ с именем "my_image".

       Флаги:
       
      -f  Удаляет образы принудительно (если они используются другими контейнерами).

   8. docker volume
     
        Управление Docker томами (постоянными хранилищами данных).
        
       Пример: docker volume create my_volume - создает новый Docker том с именем "my_volume".

        Флаги:
        
        -ls  Выводит список Docker томов.

  9.docker network
        
        Управление Docker сетями.
        
        Пример: docker network ls - отображает список Docker сетей на вашем устройстве.

        Флаги:
          create  Создает новую Docker сеть.
          inspect Отображает подробную информацию о сети.

  10. docker inspect

Команда docker inspect в Docker используется для получения подробной информации о контейнерах, образах, сетях или Docker объектах. 

Пример: docker inspect some_container - Эта команда вернет подробную информацию о контейнере с именем "some_container", включая его конфигурацию, сетевую информацию, файлы системы и т. д.

 11. docker pull
          
Используется для загрузки Docker образов из реестра Docker Hub или других реестров.
           
Пример: docker pull ubuntu:latest Загружает последний образ Ubuntu из Docker Hub на ваше устройство.
            
12. docker push
            
 Используется для загрузки Docker образов в реестра Docker Hub или других реестров.

Пример: docker push user/my_image:tag Где user - ваше имя пользователя на Docker Hub или в другом реестре, my_image - название вашего образа, и tag - тег, который вы хотите использовать для вашего образа (например, latest).

13. docker commit
              
Перед описанием следующей команды вернёмся на урок назад. Там  мы говорили о разнице между контейнером и образом, а именно что образ состоит из слоёв и не может быть изменён. Docker считывает и воспроизводит эти слои, но после запуска контейнера создаётся новый слой, в который можно вносить изменения, которые сохранятся до остановки или перезапуска контейнера.
         
![4 4 1](assets/4.4.1.png)

Если мы хотим сохранить внесённые изменения даже после перезапуска контейнера, то мы фиксируем эти изменения путём добавления "нового" слоя к образу с помощью команды docker commit.

Пример: docker commit my_container my_image:latest - создает новый образ на основе изменений контейнера "my_container".

Флаги:
    
 -m  Добавляет сообщение к коммиту.
 
 -a  Устанавливает автора образа.

 ### Квиз

 Вопрос 1:
Какая команда используется для создания нового образа в Docker, основанного на изменениях в работающем контейнере?

Варианты ответов:

a) docker create

b) docker build

c) docker commit

d) docker push

Объяснение:
Правильный ответ: c) docker commit
Команда docker commit позволяет создать новый Docker образ на основе изменений, сделанных в работающем контейнере.

---

Вопрос 2:
Какая команда используется для загрузки локального Docker образа в Docker реестр?

Варианты ответов:

a) docker load

b) docker upload

c) docker push

d) docker register

Объяснение:
Правильный ответ: c) docker push
Команда docker push используется для загрузки локального Docker образа в Docker реестр.

---

Вопрос 3:
Какая команда позволяет увидеть запущенные контейнеры?

Варианты ответов:

a) docker list

b) docker show

c) docker ps

d) docker inspect

Объяснение:
Правильный ответ: c) docker ps
Команда docker ps отображает список запущенных контейнеров.

---

Вопрос 4:
Какая команда используется для остановки работы запущенного контейнера?

Варианты ответов:

a) docker stop

b) docker kill

c) docker terminate

d) docker halt

Объяснение:
Правильный ответ: a) docker stop
Команда docker stop используется для остановки работы запущенного контейнера.

---

Можете не верить, но велика вероятность, что вам придётся работать с приложениями, которые будут состоять не из одного, а из нескольких (десятков) контейнеров. Запускать контейнеры "поштучно" в ручном режиме - очень утомительно и повышает вероятность ошибки. 

Тут на помощь приходит Docker Compose. Docker Compose - это инструмент для определения и запуска многоконтейнерных Docker приложений. Он позволяет определить все зависимости и настройки контейнеров в файле YAML, что делает развертывание и управление многоконтейнерными приложениями более удобным.

 YAML - это простой язык разметки, используемый для представления данных. 
 
Основные элементы синтаксиса YAML включают:

- **Отступы**: Используются пробелы для обозначения вложенности. Отступы имеют ключевое значение для определения структуры данных.

- **Ключ-значение пары**: Значения представлены в формате ключ: значение, где ключ и значение разделяются двоеточием.

- **Массивы**: Они представляются с помощью дефиса и пробела перед каждым элементом массива.

Давайте рассмотрим пример и попытаемся в нём разобраться.

У нас есть файл docker-compose.yml следующего содержания:

```
version: '3'

services:
  zabbix-server:
    image: zabbix/zabbix-server-mysql:latest
    ports:
      - "10051:10051"
    environment:
      - DB_SERVER_HOST=mysql-server
      - MYSQL_DATABASE=zabbix
      - MYSQL_USER=zabbix
      - MYSQL_PASSWORD=zabbix_password
      - ZBX_SERVER_NAME=zabbix-server
    links:
      - mysql-server:mysql
```

- version: '3' сообщает Docker, что файл использует схему версии 3 для определения сервисов и их конфигурации.
- image: Здесь мы определяем образ контейнера, который будет использоваться для сервиса zabbix-server. В данном случае мы используем образ Zabbix сервера с поддержкой MySQL.
- ports: Здесь мы определяем проброс портов. Эта строка означает, что порт 10051 контейнера будет проброшен на порт 10051 хоста.
- environment: Здесь мы устанавливаем переменные окружения, необходимые для работы Zabbix сервера с базой данных MySQL, такие как адрес сервера баз данных, имя базы данных, имя пользователя и пароль.
- links: Здесь мы указываем связи с другими контейнерами. В данном случае zabbix-server устанавливает связь с контейнером mysql-server, который будет размещать базу данных MySQL.


  ```
    zabbix-web:
    image: zabbix/zabbix-web-nginx-mysql:latest
    ports:
      - "8080:80"
    environment:
      - DB_SERVER_HOST=mysql-server
      - MYSQL_DATABASE=zabbix
      - MYSQL_USER=zabbix
      - MYSQL_PASSWORD=zabbix_password
      - ZBX_SERVER_HOST=zabbix-server
    links:
      - mysql-server:mysql
      - zabbix-server:zabbix-server
      ```

- image: Аналогично предыдущему сервису, здесь мы определяем образ контейнера для веб-интерфейса Zabbix, использующего Nginx и поддержку MySQL.
- ports: Эта строка пробрасывает порт 80 контейнера на порт 8080 хоста.
- environment: Мы устанавливаем необходимые переменные окружения для работы Zabbix веб-интерфейса с базой данных и сервером Zabbix.
- links: Аналогично предыдущему сервису, устанавливаем связи с другими контейнерами, mysql-server и zabbix-server.


```
  mysql-server:
    image: mysql:latest
    environment:
      - MYSQL_DATABASE=zabbix
      - MYSQL_USER=zabbix
      - MYSQL_PASSWORD=zabbix_password
      - MYSQL_ROOT_PASSWORD=root_password
    ports:
      - "3306:3306"
```


- image: Здесь определяется образ контейнера для MySQL сервера.
- environment: Устанавливаются переменные окружения для конфигурации и инициализации базы данных.
- ports: Пробрасывается порт 3306 контейнера на порт 3306 хоста для доступа к базе данных.

Эти три сервиса позволяют развернуть систему мониторинга Zabbix вместе с базой данных MySQL и веб-сервером Nginx с помощью одной команды: docker-compose up. Благодаря параметрам ports, environment и links мы настраиваем связи и конфигурации для каждого сервиса.

Команды docker compose во многом перекликаются с docker, вот несколько примеров:

- docker-compose up: Запускает все контейнеры, определенные в файле docker-compose.yml.
- docker-compose down: Останавливает и удаляет все контейнеры, определенные в файле docker-compose.yml.
- docker-compose ps: Отображает текущий статус всех контейнеров, определенных в файле docker-compose.yml.
- docker-compose build: Собирает или пересобирает сервисы, определенные в файле docker-compose.yml.
- docker-compose start: Запускает остановленные сервисы.
- docker-compose stop: Останавливает запущенные сервисы.
- docker-compose restart: Перезапускает сервисы.
- docker-compose exec: Запускает команду внутри контейнера, например: docker-compose exec webserver sh.
- docker-compose logs: Показывает логи сервисов.
- docker-compose pull: Вытягивает образы для сервисов из реестра.

Такой подход позволяет, значительно увеличить скорость развёртывания и восстановления сервисов, улучшить отказоустойчивость и изолированность сервисов.

### Квиз

### Вопрос 1:
Какая команда используется для запуска всех контейнеров, определенных в файле docker-compose.yml?
- A) docker run
- B) docker start
- C) docker-compose start
- D) docker-compose up

Правильный ответ: D
Объяснение: Команда docker-compose up используется для запуска всех контейнеров, определенных в файле docker-compose.yml.

### Вопрос 2:
Какой ключевой инструмент позволяет определить данные в удобочитаемом формате в файлах конфигурации для Docker?
- A) JSON
- B) XML
- C) YAML
- D) HTML

Правильный ответ: C
Объяснение: YAML используется для определения данных в удобочитаемом формате в файлах конфигурации для Docker.

### Вопрос 3:
Что такое отсутствие конфликтов ресурсов между разными приложениями в контейнерах Docker?
- A) Изоляция
- B) Масштабируемость
- C) Отказоустойчивость
- D) Интеграция

Правильный ответ: A
Объяснение: Docker контейнеры обеспечивают изоляцию ресурсов, что предотвращает конфликты ресурсов между различными приложениями.

### Вопрос 4:
Какая команда позволяет отобразить текущий статус всех контейнеров, определенных в файле docker-compose.yml?
- A) docker ps
- B) docker-compose status
- C) docker-compose ps
- D) docker-compose status

Правильный ответ: C
Объяснение: Команда docker-compose ps позволяет отобразить текущий статус всех контейнеров, определенных в файле docker-compose.yml.

 ### Практическое задание с самопроверкой

 Мы много сегодня говорили о работе с контейнерами, пора бы что-то сделать руками.

 Подключитесь к своему рабочему месту и создайте виртуальную машину. Подключитесь к виртуальной машине.

 С помощью команды sudo apt update обновите список репозиториев. Далее попробуйте ввести команды docker и docker compose(docker-compose), эти компоненты не установлены в ОС, но система даст вам подсказку как установить нужные пакеты. Кстати, docker-compose и docker compose это не совсем одно и то же, docker compose, по сути, является версией 2.0. Система подскажет как установить "docker-compose", установку "docker compose" будем считать задачей со звёздочкой. Не забывайте про sudo.

 После того, как вы установите необходимые пакеты, выполните команды, которые мы разобрали в этом уроке, например:
 
```
sudo docker run -d --name my_container -p 8085:80 nginx

 ```
 После этого перейдитепо адресу: http://ip_адрес_ВМ:8085, вы увидите начальную страницу web-сервера nginx. Запустите несколько контейнеров на разных портах или другими параметрами.
 
 Выведите список всех запущенных контейнеров. Подключитесь внутрь контейнера, установите новый пакет, например Midnight Comande, и сохраните эти изменения, сделав из запущенного контейнера новый образ. 

 Далее запустите систему мониторинга zabbix с помощью docker-compose. Более подробно про мониторинг поговорим в следующей теме, в этой же просто запустим её в качестве демонстрации.

Скопируем из официального репозитория готовые yaml-файлы:

```
git clone https://github.com/zabbix/zabbix-docker.git
```

Перейдём в скачанную папку:

```
cd zabbix-docker/
```

В файле .env поменяйте 80 порт на другой, чтобы он не пересекался с web-серверами в уже запущенных контейнерах.

Далее запустите контейнеры с помощью yaml-файла:

```
docker-compose -f ./docker-compose_v3_alpine_mysql_latest.yaml up -d
```

Перейдя в браузере по адресу: http://ip_адрес_ВМ:номер указанного порта вы увидите начальный экран Zabbix логин и пароль по умолчанию. При первом запуске, нужно подождать пару минут после запуска контейнеров, чтобы web-страница стала доступна.

Попробуйте удалить полностью все контейнеры(вместе с образами) и запустить контейнеры заново, например, с предыдущей (не последней) версией образа. 


В этом уроке мы узнали основные команды docker, узнали как и для чего их применять. В каких случаях использовать команды, а в каких dockerfile для запуска образа. В чём преимущества того и другого способов.  Узнали что такое docker Compose, для чего он нужен, основные команды.
