## Урок 2. Условные конструкции, циклы и функции 

Вам уже знакомы эти концепции из предыдущих уроков (про Bash и PowerShell), вспомним, что это такое, и научимся использовать эти конструкции на языке Phython. Разберём последовательно каждую конструкцию.

Начнём с условных операторов. Условные операторы if, elif (сокращение от else if) и else в Python используются для принятия решений на основе определенных условий. Они позволяют программе выполнять определенные действия в зависимости от того, выполняется ли определенное условие или нет.

1. Оператор if:
Оператор if позволяет проверить одно или несколько условий и выполнить определенный блок кода, если условие истинно. Синтаксис оператора if выглядит следующим образом:

```
if условие:
    # выполнить блок кода, если условие истинно
```

Пример:
```
x = 10
if x > 5:
    print("x больше 5")
```

2. Оператор elif:
Оператор elif позволяет проверить новое условие, если предыдущее условие не было истинно. Это позволяет программе выполнить различные действия в зависимости от выполнения разных условий. Синтаксис оператора elif выглядит следующим образом:

```
if условие1:
    # выполнить блок кода, если условие1 истинно
elif условие2:
    # выполнить блок кода, если условие2 истинно
```

Пример:
```
x = 10
if x > 15:
    print("x больше 15")
elif x > 5:
    print("x больше 5, но меньше 15")
```

3. Оператор else:
Оператор else используется, когда ни одно из предыдущих условий не было выполнено. Если условие в операторе if или elif не было истинно, то выполнится блок кода, указанный после оператора else. Синтаксис оператора else выглядит следующим образом:

```
if условие:
    # выполнить блок кода, если условие истинно
else:
    # выполнить блок кода, если условие ложно
```

Пример:
```
x = 2
if x > 5:
    print("x больше 5")
else:
    print("x меньше или равен 5")
 ```

Эти операторы могут быть использованы в любых комбинациях для более сложных проверок и принятия решений в программе в зависимости от различных условий.

От операторов перейдём к булевым операторам. Булевы операторы в Python используются для комбинирования условий и выполнения различных логических операций.

1. Оператор and: and возвращает True, если оба операнда равны True, и False в остальных случаях.
   Пример:
     ```
     x = True
     y = False
     result = x and y  # False, так как оба операнда не равны True
     print(result)  # Вывод: False
   ```  

2. Оператор or:or возвращает True, если хотя бы один из операндов равен True, и False если оба операнда равны False.
   Пример:
     ```
     x = True
     y = False
     result = x or y  # True, так как один из операндов равен True
     print(result)  # Вывод: True
    ``` 

3. Оператор not: not возвращает True, если операнд равен False, и False, если операнд равен True.
   Пример:

     ```
     x = True
     result = not x  # False, так как операнд равен True
     print(result)  # Вывод: False
     ```


4.  Оператор & (побитовое И): Применяется к каждому биту операндов. Возвращает 1 в каждой позиции, где оба бита в операндах равны 1, и 0 во всех остальных позициях.
Пример:
     ```
     x = 5  # Битовое представление 0101
     y = 3  # Битовое представление 0011
     result = x & y  # 0101 & 0011 = 0001 (двоичное) = 1 (десятичное)
     print(result)  # Вывод: 1
     ```

5. Оператор | (побитовое ИЛИ): Также применяется к каждому биту операндов. Возвращает 1 в каждой позиции, где хотя бы один из битов в операндах равен 1, и 0 в остальных позициях.
   Пример:
     ```
     x = 5  # Битовое представление 0101
     y = 3  # Битовое представление 0011
     result = x | y  # 0101 | 0011 = 0111 (двоичное) = 7 (десятичное)
     print(result)  # Вывод: 7
     ```

Комбинируя условия с использованием булевых операторов, можно создавать более сложные проверки и решать задачи, требующие более сложной логики принятия решений.


### Квиз 

1. Есть код:

```
if not (10 < 5 or 5 > 3):
    print("Оба условия ложны")
elif 10 > 5 and 5 < 3:
    print("Это невозможно")
else:
    print("Хотя бы одно условие истинно")
```

Вопрос: Какая строчка будет выполнена?

a. if Верно.  Условие not (10 < 5 or 5 > 3) ложно, так как хотя бы одно из условий в скобках истинно (5 > 3). Поэтому выполняется строка if.

b. elif

c. else


2. Есть код:

```
x = 5
y = 10

if x > 3 and y < 5:
    print("Условие 1")
elif x < 10 and y > 8:
    print("Условие 2")
elif x == 5 or y == 5:
    print("Условие 3")
else:
    print("Условие 4")
```
Вопрос: Какая строчка будет выполнена?

a. Условие 1.

b. Условие 2. Верно.

c. Условие 3.

d. Условие 4

3. Есть код:

```
x = 10

if x > 5
    print("x is greater than 5")
elif x > 15
    print("x is greater than 15")
else
    print("x is 5 or less")

```

Что в нём не так? Что нужно сделать, чтобы он заработал?

Правильный ответ: Добавить двоеточие после каждого условия:

```

x = 10

if x > 5:  # Верно: добавлен символ двоеточия после условия
    print("x is greater than 5")
elif x > 15:  # Ошибка: второе условие неверное, так как x не может быть больше 15 и больше 5 одновременно
    print("x is greater than 15")
else:  # Ошибка: пропущен символ двоеточия после else
    print("x is 5 or less")

```

4. Есть код:

```
if not x > 5:
    print("x не больше 5")
elif x == 10:
    print("x равно 10")

```

Что в нём не так? Что нужно сделать, чтобы он заработал?

Правильный ответ: Условие not x > 5 эквивалентно x <= 5, поэтому выполнение сразу перейдет к блоку if, если x меньше или равно 5. Блок elif никогда не будет выполнен:

```
if x > 5:
    print("x больше 5")
elif x == 10:
    print("x равно 10")
else:
    print("x не больше 5")
```

---

Иногда в разных частях программы нужно выполнять одинаковые действия. Самый простой подход в такой ситуации — взять готовый кусок кода и скопировать его туда, где требуется повторить выполнение. 

Например, вы написали скрипт, который должен проверять наличие появившихся файлов в дериктории: если появилися файл — переменная new_file станет больше ноля, и скрипт сообщит об этом.

Ниже листинг части скрипта:

```

new_file = 0
if new_file > 0:
    print('Появился файл, не пропусти!')
else:
    print('Никто не пишет.')
# Тут код, отсчитывающий минуту

# И снова проверим файл
if new_file > 0:
    print('Появился файл, не пропусти!')
else:
    print('Файла нет.')
# Тут код, отсчитывающий минуту

# И снова
if new_file > 0:
    print('Появился файл, не пропусти!')
else:
    print('Файла нет.')
# Тут код, отсчитывающий минуту

# За это время файл появился:
new_file = 1
# И снова проверка
if new_file > 0:
    print('Появился файл, не пропусти!')
else:
    print('Файла нет.')
```
Результат работы:

```
Никто не пишет.
Никто не пишет.
Никто не пишет.
Появился файл, не пропусти!

```

Работает? Работает. 

Но сколько же нужно кода, чтобы проверка работала круглые сутки?

Если скрипт или программа сложная — она очень быстро превратится в винегрет из повторяющихся фрагментов кода, разобраться в котором будет невозможно.

От хаоса и беспросветности разработчиков спасают функции.

Функция — это именованный блок кода, выполняющий определённую задачу. Код функции можно использовать многократно, надо лишь вызвать её — обратиться к ней по имени. 

В Python есть множество заготовленных (встроенных) функций,например: print(). 

Но можно создавать и собственные функции:

```

new_file = 0

# Создадим собственную функцию и дадим ей имя check_mail ("проверка файла")
# В эту функцию поместим код проверки наличия файла.
def check_file():
    if new_file > 0:
        print('Появился файл, не пропусти!')
    else:
        print('Никто не пишет.')

# Тут код, отсчитывающий минуту

# Проверим файл - вызовем функцию check_file(): 
# запустим код, который хранится в функции.
check_file()

# Тут код, отсчитывающий минуту

# И снова вызовем функцию:
check_file()

# Тут код, отсчитывающий минуту
# За это время файл появился:
new_file = 1

# И снова вызовем функцию:
check_file() 

```
Код стал гораздо короче, а работает точно так же. Удобно, красиво, лаконично.

Всё начинается с объявления функции, со строки, которая означает «здесь мы создаём новую функцию». 
Функцию объявляют ключевым словом def, затем указывают имя функции (его придумывает разработчик), после имени — круглые скобки и двоеточие. 

За объявлением функции следует код, который функция должна выполнить при вызове. Этот код называется телом функции. Тело функции отбивается четырьмя пробелами от начала строки: по этим отступам Python понимает, где начинается и заканчивается тело функции. Нет отступов — нет тела функции.

Объявим функцию, которая будет приветствовать системного администратора:

```
# Объявление функции hello()
def hello():
    # А здесь началось тело функции
    print('Приветствую тебя, джедай!')
```
Готово!

Но если выполнить этот код — ничего не произойдёт. Совсем-совсем ничего.
Функция не выполнится до тех пор, пока где-то в коде программы не будет вызова функции, команды: «Функция, делай свою работу!».

Чтобы вызвать функцию — нужно «позвать» её по имени: написать название функции и  после названия поставить круглые скобки.
Выполните код. Ничего не произойдёт, приветствие не будет напечатано: функция есть, но она не вызвана.

То есть в нашем случае, чтобы увидеть приветствие, нужно выполнить следующий код:

```
def hello():
    print('Приветствую тебя, джедай!')

hello()
```
Код, описанный в теле функции hello(), можно вызывать сколько угодно раз.

С приветствием понятно: вызвали — поздоровались. Но это довольно простой пример: при вызове функция hello() постоянно выводит одну и ту же строку.

А что делать, если нужно поздороваться, но в приветствии упомянуть имя: "Максим, приветствую тебя!"?

Можно так:
```
def hello():
    print('Максим, приветствую тебя!')

hello()
```
Но тогда придётся для каждого имени писать новую функцию. Хорошо бы вместо имени подставить переменную:

```
def hello():
    print(name + ', приветствую тебя!')

hello() 
```

Красиво, но не сработает: функция не знает, что за переменная name и какое у неё значение. 

Решение есть: при объявлении функции можно указывать параметры функции — переменные, которые будут обрабатываться в её теле. Имена для параметров придумывает сам разработчик.

Значения для этих параметров передаются при вызове — их называют аргументами функции. Аргументы функции — это данные, которые мы передаем в функцию, чтобы она могла с ними работать. 

Параметры указывают в круглых скобках при объявлении функции; аргументы указывают при вызове функции.

<img width="1440" alt="10 2 2 1" src="https://github.com/lexche/Testyp/assets/95694325/a8579058-769b-4e66-96ab-3dc7a3068dca">

Запустите код. При вызове функции строка 'Максим' будет присвоена переменной name, это значение будет подставлено в строку, которую напечатает функция print():

```
# Объявление функции с параметром name
def hello(name):
    # Параметр name можно обрабатывать в теле функции:
    print(name + ', приветствую тебя!')

# Вызов функции с аргументом 'Максим'
hello('Максим')
# Будет напечатано: Максим, приветствую тебя!

```
У функции может быть и несколько параметров, в этом случае они перечисляются через запятую. При вызове функции аргументы передаются в соответствии с порядком записи (тоже через запятую): первый аргумент передаётся в первый параметр, второй аргумент — во второй параметр.

```
# Теперь у функции hello() два параметра: name и bonus
def hello(name, bonus):
    # Оба параметра применим в теле функции:
    print(name + ', приветствую тебя! Бери ' + bonus)

hello('Дарт Вейдер', 'печеньки')
```

Значения, переданные в функцию, проходят такой путь:

<img width="1440" alt="10 2 2 2" src="https://github.com/lexche/Testyp/assets/95694325/0f714c26-4e1e-49c2-bf2d-bd02120a1866">

Функция — такой же составной блок кода, как циклы и операторы. Их можно комбинировать между собой. Например, вызывать функцию в теле цикла:

```
def hello(name):
      print('Привет, ' + name)

students = ['Ира', 'Маша', 'Ваня', 'Петя']

for student in students:
    hello(student)
```
А можно и наоборот: переписать эту программу так, чтобы цикл был внутри тела функции:

```
students = ['Ира', 'Маша', 'Ваня', 'Петя']

def hello():
    for student in students:
          print('Привет, ' + student)

hello() 
```
До сих пор мы рассматривали функции, которые печатали результаты вычислений на экран. Но обычно задача функции не сводится к печати: вычисленное в функции значение передаётся в код, и с этим значением производится ещё какая-то работа. 

Функция должна работать подобным образом: в неё поступает «заготовка» — аргументы, переданные при вызове, а на выход функция выдаёт какой-то результат, возвращает его в ту часть кода, откуда она была вызвана. В дальнейшей работе программа применит значение, вернувшееся из функции, для каких-то дальнейших вычислений.

Возвращаемое значение указывается в теле функции после ключевого слова return.

Функция calc_square() получает на вход два аргумента — длины сторон прямоугольника,  вычисляет и возвращает его площадь.  Запустите код, посмотрите, что будет выведено в терминал.

```
# Функция для вычисления площади прямоугольника;
# от англ. calculate, «вычислять»
def calc_square(side_a, side_b):
    # Вычисляем площадь и присваиваем результат переменной result
    result = side_a * side_b
    # Функция возвращает значение переменной result:
    return result

# Вызываем функцию calc_square() с аргументами 16 и 9. 
# Значение, которое вернёт функция, будет присвоено переменной rectangle_area
rectangle_area = calc_square(16, 9)

print(rectangle_area)

```

Обратите внимание: сама функция calc_square() ничего не печатает, в ней нет вызова print(). Функция calc_square() была вызвана в строке rectangle_area = calc_square(16, 9); она произвела нужные вычисления и передала («вернула») получившееся значение в переменную rectangle_area. И это значение было напечатано уже вне функции, в основном коде программы.

Вернёмся к истории с квартирой: напишем небольшую программу, которая вычислит и напечатает суммарную площадь трёх жилых комнат, размеры которых нам известны: 3х5, 4х6 и 3х6 метров. Для этого пригодится та же функция calc_square().

Здесь не обойтись без нескольких последовательных действий:

1.Получим площадь каждой комнаты: поочерёдно передадим в функцию calc_square() размеры каждой комнаты; результаты вызовов функции сохраним в отдельные переменные: в них будут храниться площади трёх комнат.

2.Просуммируем полученные площади.

3.Напечатаем результат.

def calc_square(side_a, side_b):
    result = side_a * side_b
    # Функция возвращает значение переменной result:
    return result

```
# Вызовем функцию calc_square(), передав в неё размеры первой комнаты;
# функция вычислит площадь комнаты и вернёт её;
# вернувшееся значение присвоим переменной room1.
room1 = calc_square(3, 5)

# Вычислим и сохраним в переменную room2 площадь второй комнаты:
room2 = calc_square(4, 6)

# Площадь третьей комнаты сохраним в room3:
room3 = calc_square(3, 6)

# Теперь можно суммировать полученные значения и напечатать результат:

rooms_sum = room1 + room2 + room3
print('Суммарная площадь комнат равна', rooms_sum, 'кв.м')
```
### Практическое задание

1. Выберите, как называются разные блоки программы ниже:
2. 
   ```
   students = ['Ира', 'Маша', 'Ваня', 'Петя']

def hello():                        # A
    for student in students:
          print('Привет, ' + student)  # B

hello()                             # C 

    ```

a. A - объявление функции, B - тело цикла, С - вызов функции Верно

b. B - объявление функции, A - тело цикла, С - вызов функции

c. C - объявление функции, B - тело цикла, A - вызов функции

2. Доработайте программу подсчёта тёплых дней в мае 2017 г. : допишите функцию comfort_count() так, чтобы она возвращала подсчитанное количество тёплых дней.

```
may_2023 = [24, 26, 15, 10, 15, 19, 10, 1, 4, 7, 7, 7, 12, 14, 17, 8, 9, 19, 21, 22, 11, 15, 19, 23, 15, 21, 16, 13, 25, 17, 19]

# Допишите эту функцию
def comfort_count(temperatures):
    count = 0
    for temp in temperatures:
        if 22 <= temp <= 26:
            count += 1
    # Функция должна вернуть значение переменной count
    ...

# Код ниже не изменяйте:
# вызовем функцию comfort_count(), передадим в неё список may_2023,
# результат работы сохраним в переменную nice_days
nice_days = comfort_count(may_2023)

# Напечатаем значение, сохранённое в nice_days
print('Количество тёплых дней в этом месяце:', nice_days)
```

Решение:

```
may_2023 = [24, 26, 15, 10, 15, 19, 10, 1, 4, 7, 7, 7, 12, 14, 17, 8, 9, 19, 21, 22, 11, 15, 19, 23, 15, 21, 16, 13, 25, 17, 19]


def comfort_count(temperatures):
    count = 0
    for temp in temperatures:
        if 22 <= temp <= 26:
            count += 1
    return count

# Код ниже не изменяйте:
# вызовем функцию comfort_count(), передадим в неё список may_2023,
# результат работы сохраним в переменную nice_days
nice_days = comfort_count(may_2023)

# Напечатаем значение, сохранённое в nice_days
print('Количество тёплых дней в этом месяце:', nice_days)
```
3. Есть 2 списка: Студенты и Преподаватели.
 ```
students = ['Emma','Liam','Olivia','Noah','Ava','William','Isabella','James','Sophia','Logan','Mia','Elijah','Charlotte','Carter','Amelia','Oliver','Evelyn','Mason','Harper','Ethan','Emily','Alexander','Avery','Sebastian','Scarlett','Michael','Grace','Daniel','Chloe','Jacob','Zoey','Benjamin','Lily','Luke','Madison','Matthew','Aubrey','Henry','Layla','Joseph','Lillian','Caleb','Nora','Wyatt','Elizabeth','Owen','Abigail','Jack','Ella','Samuel','Addison']

mentors = {
    'Alice': 0,
    'Charlie': 0,
    'David': 0
}
```
1.Разбейте студентов на 3 группы(подвоха нет, в списке 51 студент, прекрасно делиться.)
2. Назначте каждому преподавателю по группе и выведите этот список на экран

Итак, для выполнения этого задания вам понадобятся функции:

```
1. def divide_students(students, num_groups):
    group_size = len(students) // num_groups
    return [students[i:i+group_size] for i in range(0, len(students), group_size)]

2. def assign_mentors(groups, mentors):
    sorted_mentors = sorted(mentors.items(), key=lambda x: x[1])
    mentors_list = [mentor[0] for mentor in sorted_mentors]

    result = {}
    for idx, group in enumerate(groups):
        mentor = mentors_list[idx % len(mentors_list)]
        result[f'Group {idx+1}'] = {'Students': group, 'Mentor': mentor}
        mentors[mentor] += 1

    return result
```
1.  Функция dividestudents(students, numgroups):

   - Эта функция принимает словарь студентов и количество групп, на которые их нужно разделить.

   - Первая строка вычисляет размер каждой группы по формуле len(students) // numgroups, где len(students) - количество студентов.

   - Возвращается список списков студентов, разделенных на группы, используя list comprehension.

2.  Функция assignmentors(groups, mentors):

   - Эта функция принимает список групп студентов и словарь менторов.

   - Сортирует менторов по значению (предположительно, количество студентов, которых они могут взять).

   - Создает список имен менторов на основе отсортированного списка.

   - Далее создается пустой словарь 'result', в котором будут храниться данные о группах студентов и их менторах.

   - Затем происходит перебор групп студентов. Каждая группа сопоставляется с ментором из списка менторов.

   - Информация о группе и менторе добавляется в словарь 'result'.

   - После этого увеличивается счетчик студентов у ментора в словаре менторов.

   - В конце функция возвращает словарь 'result' с информацией о группах студентов и их менторах.

В итоге начало вашего скрипта будет выглядеть:

```
students = ['Emma','Liam','Olivia','Noah','Ava','William','Isabella','James','Sophia','Logan','Mia','Elijah','Charlotte','Carter','Amelia','Oliver','Evelyn','Mason','Harper','Ethan','Emily','Alexander','Avery','Sebastian','Scarlett','Michael','Grace','Daniel','Chloe','Jacob','Zoey','Benjamin','Lily','Luke','Madison','Matthew','Aubrey','Henry','Layla','Joseph','Lillian','Caleb','Nora','Wyatt','Elizabeth','Owen','Abigail','Jack','Ella','Samuel','Addison']

mentors = {
    'Alice': 0,
    'Charlie': 0,
    'David': 0
}

def divide_students(students, num_groups):
    group_size = len(students) // num_groups
    return [students[i:i+group_size] for i in range(0, len(students), group_size)]

def assign_mentors(groups, mentors):
    sorted_mentors = sorted(mentors.items(), key=lambda x: x[1])
    mentors_list = [mentor[0] for mentor in sorted_mentors]

    result = {}
    for idx, group in enumerate(groups):
        mentor = mentors_list[idx % len(mentors_list)]
        result[f'Group {idx+1}'] = {'Students': group, 'Mentor': mentor}
        mentors[mentor] += 1

    return result
```

Ответ: Часть которую должен дописать студент:

```

# 1.Разбиваем студентов на когорты
num_groups = 3
groups = divide_students(students, num_groups)

# 2. Назначаем наставников для каждой когорты
assigned_groups = assign_mentors(groups, mentors)

for group, data in assigned_groups.items():
    print(f'{group}: {data}')
```

