## Урок 2. Условные конструкции, циклы и функции 

Вам уже знакомы эти концепции из предыдущих уроков (про Bash и PowerShell), вспомним, что это такое, и научимся использовать эти конструкции на языке Phython. Разберём последовательно каждую конструкцию.

Начнём с условных операторов. Условные операторы if, elif (сокращение от else if) и else в Python используются для принятия решений на основе определенных условий. Они позволяют программе выполнять определенные действия в зависимости от того, выполняется ли определенное условие или нет.

1. Оператор if:
Оператор if позволяет проверить одно или несколько условий и выполнить определенный блок кода, если условие истинно. Синтаксис оператора if выглядит следующим образом:

```
if условие:
    # выполнить блок кода, если условие истинно
```

Пример:
```
x = 10
if x > 5:
    print("x больше 5")
```

2. Оператор elif:
Оператор elif позволяет проверить новое условие, если предыдущее условие не было истинно. Это позволяет программе выполнить различные действия в зависимости от выполнения разных условий. Синтаксис оператора elif выглядит следующим образом:

```
if условие1:
    # выполнить блок кода, если условие1 истинно
elif условие2:
    # выполнить блок кода, если условие2 истинно
```

Пример:
```
x = 10
if x > 15:
    print("x больше 15")
elif x > 5:
    print("x больше 5, но меньше 15")
```

3. Оператор else:
Оператор else используется, когда ни одно из предыдущих условий не было выполнено. Если условие в операторе if или elif не было истинно, то выполнится блок кода, указанный после оператора else. Синтаксис оператора else выглядит следующим образом:

```
if условие:
    # выполнить блок кода, если условие истинно
else:
    # выполнить блок кода, если условие ложно
```

Пример:
```
x = 2
if x > 5:
    print("x больше 5")
else:
    print("x меньше или равен 5")
 ```

Эти операторы могут быть использованы в любых комбинациях для более сложных проверок и принятия решений в программе в зависимости от различных условий.

От операторов перейдём к булевым операторам. Булевы операторы в Python используются для комбинирования условий и выполнения различных логических операций.

1. Оператор and: and возвращает True, если оба операнда равны True, и False в остальных случаях.
   Пример:
     ```
     x = True
     y = False
     result = x and y  # False, так как оба операнда не равны True
     print(result)  # Вывод: False
   ```  

2. Оператор or:or возвращает True, если хотя бы один из операндов равен True, и False если оба операнда равны False.
   Пример:
     ```
     x = True
     y = False
     result = x or y  # True, так как один из операндов равен True
     print(result)  # Вывод: True
    ``` 

3. Оператор not: not возвращает True, если операнд равен False, и False, если операнд равен True.
   Пример:

     ```
     x = True
     result = not x  # False, так как операнд равен True
     print(result)  # Вывод: False
     ```


4.  Оператор & (побитовое И): Применяется к каждому биту операндов. Возвращает 1 в каждой позиции, где оба бита в операндах равны 1, и 0 во всех остальных позициях.
Пример:
     ```
     x = 5  # Битовое представление 0101
     y = 3  # Битовое представление 0011
     result = x & y  # 0101 & 0011 = 0001 (двоичное) = 1 (десятичное)
     print(result)  # Вывод: 1
     ```

5. Оператор | (побитовое ИЛИ): Также применяется к каждому биту операндов. Возвращает 1 в каждой позиции, где хотя бы один из битов в операндах равен 1, и 0 в остальных позициях.
   Пример:
     ```
     x = 5  # Битовое представление 0101
     y = 3  # Битовое представление 0011
     result = x | y  # 0101 | 0011 = 0111 (двоичное) = 7 (десятичное)
     print(result)  # Вывод: 7
     ```

Комбинируя условия с использованием булевых операторов, можно создавать более сложные проверки и решать задачи, требующие более сложной логики принятия решений.


### Квиз 

1. Есть код:

```
if not (10 < 5 or 5 > 3):
    print("Оба условия ложны")
elif 10 > 5 and 5 < 3:
    print("Это невозможно")
else:
    print("Хотя бы одно условие истинно")
```

Вопрос: Какая строчка будет выполнена?

a. if Верно.  Условие not (10 < 5 or 5 > 3) ложно, так как хотя бы одно из условий в скобках истинно (5 > 3). Поэтому выполняется строка if.

b. elif

c. else


2. Есть код:

```
x = 5
y = 10

if x > 3 and y < 5:
    print("Условие 1")
elif x < 10 and y > 8:
    print("Условие 2")
elif x == 5 or y == 5:
    print("Условие 3")
else:
    print("Условие 4")
```
Вопрос: Какая строчка будет выполнена?

a. Условие 1.

b. Условие 2. Верно.

c. Условие 3.

d. Условие 4

3. Есть код:

```
x = 10

if x > 5
    print("x is greater than 5")
elif x > 15
    print("x is greater than 15")
else
    print("x is 5 or less")

```

Что в нём не так? Что нужно сделать, чтобы он заработал?

Правильный ответ: Добавить двоеточие после каждого условия:

```

x = 10

if x > 5:  # Верно: добавлен символ двоеточия после условия
    print("x is greater than 5")
elif x > 15:  # Ошибка: второе условие неверное, так как x не может быть больше 15 и больше 5 одновременно
    print("x is greater than 15")
else:  # Ошибка: пропущен символ двоеточия после else
    print("x is 5 or less")

```

4. Есть код:

```
if not x > 5:
    print("x не больше 5")
elif x == 10:
    print("x равно 10")

```

Что в нём не так? Что нужно сделать, чтобы он заработал?

Правильный ответ: Условие not x > 5 эквивалентно x <= 5, поэтому выполнение сразу перейдет к блоку if, если x меньше или равно 5. Блок elif никогда не будет выполнен:

```
if x > 5:
    print("x больше 5")
elif x == 10:
    print("x равно 10")
else:
    print("x не больше 5")
```

---

Иногда в разных частях программы нужно выполнять одинаковые действия. Самый простой подход в такой ситуации — взять готовый кусок кода и скопировать его туда, где требуется повторить выполнение. 

Например, вы написали скрипт, который должен проверять наличие появившихся файлов в дериктории: если появилися файл — переменная new_file станет больше ноля, и скрипт сообщит об этом.

Ниже листинг части скрипта:

```

new_file = 0
if new_file > 0:
    print('Появился файл, не пропусти!')
else:
    print('Никто не пишет.')
# Тут код, отсчитывающий минуту

# И снова проверим файл
if new_file > 0:
    print('Появился файл, не пропусти!')
else:
    print('Файла нет.')
# Тут код, отсчитывающий минуту

# И снова
if new_file > 0:
    print('Появился файл, не пропусти!')
else:
    print('Файла нет.')
# Тут код, отсчитывающий минуту

# За это время файл появился:
new_file = 1
# И снова проверка
if new_file > 0:
    print('Появился файл, не пропусти!')
else:
    print('Файла нет.')
```
Результат работы:

```
Никто не пишет.
Никто не пишет.
Никто не пишет.
Появился файл, не пропусти!

```

Работает? Работает. 

Но сколько же нужно кода, чтобы проверка работала круглые сутки?

Если скрипт или программа сложная — она очень быстро превратится в винегрет из повторяющихся фрагментов кода, разобраться в котором будет невозможно.

От хаоса и беспросветности разработчиков спасают функции.

Функция — это именованный блок кода, выполняющий определённую задачу. Код функции можно использовать многократно, надо лишь вызвать её — обратиться к ней по имени. 

В Python есть множество заготовленных (встроенных) функций,например: print(). 

Но можно создавать и собственные функции:

```

new_file = 0

# Создадим собственную функцию и дадим ей имя check_mail ("проверка файла")
# В эту функцию поместим код проверки наличия файла.
def check_file():
    if new_file > 0:
        print('Появился файл, не пропусти!')
    else:
        print('Никто не пишет.')

# Тут код, отсчитывающий минуту

# Проверим файл - вызовем функцию check_file(): 
# запустим код, который хранится в функции.
check_file()

# Тут код, отсчитывающий минуту

# И снова вызовем функцию:
check_file()

# Тут код, отсчитывающий минуту
# За это время файл появился:
new_file = 1

# И снова вызовем функцию:
check_file() 

```
Код стал гораздо короче, а работает точно так же. Удобно, красиво, лаконично.

Всё начинается с объявления функции, со строки, которая означает «здесь мы создаём новую функцию». 
Функцию объявляют ключевым словом def, затем указывают имя функции (его придумывает разработчик), после имени — круглые скобки и двоеточие. 

За объявлением функции следует код, который функция должна выполнить при вызове. Этот код называется телом функции. Тело функции отбивается четырьмя пробелами от начала строки: по этим отступам Python понимает, где начинается и заканчивается тело функции. Нет отступов — нет тела функции.

Объявим функцию, которая будет приветствовать системного администратора:

```
# Объявление функции hello()
def hello():
    # А здесь началось тело функции
    print('Приветствую тебя, джедай!')
```
Готово!

Но если выполнить этот код — ничего не произойдёт. Совсем-совсем ничего.
Функция не выполнится до тех пор, пока где-то в коде программы не будет вызова функции, команды: «Функция, делай свою работу!».

Чтобы вызвать функцию — нужно «позвать» её по имени: написать название функции и  после названия поставить круглые скобки.
Выполните код. Ничего не произойдёт, приветствие не будет напечатано: функция есть, но она не вызвана.

То есть в нашем случае, чтобы увидеть приветствие, нужно выполнить следующий код:

```
def hello():
    print('Приветствую тебя, джедай!')

hello()
```
Код, описанный в теле функции hello(), можно вызывать сколько угодно раз. Кстати, добавьте ещё пару вызовов, каждый — на отдельной строке, и снова запустите код.

С приветствием понятно: вызвали — поздоровались. Но это довольно простой пример: при вызове функция hello() постоянно выводит одну и ту же строку.
А что делать, если нужно поздороваться, но в приветствии упомянуть имя: "Максим, приветствую тебя!"?

Можно так:
```
def hello():
    print('Максим, приветствую тебя!')

hello() 
Но тогда придётся для каждого имени писать новую функцию. Хорошо бы вместо имени подставить переменную:
def hello():
    print(name + ', приветствую тебя!')

hello() 
```

Красиво, но не сработает: функция не знает, что за переменная name и какое у неё значение. 

Решение есть: при объявлении функции можно указывать параметры функции — переменные, которые будут обрабатываться в её теле. Имена для параметров придумывает сам разработчик.

Значения для этих параметров передаются при вызове — их называют аргументами функции.

Параметры указывают в круглых скобках при объявлении функции; аргументы указывают при вызове функции.

<img width="1440" alt="10 2 2 1" src="https://github.com/lexche/Testyp/assets/95694325/a8579058-769b-4e66-96ab-3dc7a3068dca">

Запустите код. При вызове функции строка 'Максим' будет присвоена переменной name, это значение будет подставлено в строку, которую напечатает функция print():

```
# Объявление функции с параметром name
def hello(name):
    # Параметр name можно обрабатывать в теле функции:
    print(name + ', приветствую тебя!')

# Вызов функции с аргументом 'Максим'
hello('Максим')
# Будет напечатано: Максим, приветствую тебя!

# Раскомментируйте строку ниже, в качестве аргумента подставьте своё имя -
# и снова выполните код.
# hello('Имя')
```
У функции может быть и несколько параметров, в этом случае они перечисляются через запятую. При вызове функции аргументы передаются в соответствии с порядком записи (тоже через запятую): первый аргумент передаётся в первый параметр, второй аргумент — во второй параметр.

```
# Теперь у функции hello() два параметра: name и bonus
def hello(name, bonus):
    # Оба параметра применим в теле функции:
    print(name + ', приветствую тебя! Бери ' + bonus)


hello('Дарт Вейдер', 'печеньки')
```

Значения, переданные в функцию, проходят такой путь:

<img width="1440" alt="10 2 2 2" src="https://github.com/lexche/Testyp/assets/95694325/0f714c26-4e1e-49c2-bf2d-bd02120a1866">


