## Комментарий
Я перекроил урок, так как time-sharing поперёк всего, про него либо в 1м уроке рассказывать, в классификации ОС, либо после процессов сразу, кроме того, жизненные циклы процессов перенёс к основному блоку про процессы, чтобы более-менее единое полотно повествования сохранилось. Итого: Системные вызовы(так как они упомянались в прошлом уроке), процессы, time-sharing, говорим про безопасность.

## Урок 3. Процессы и системные вызовы.

Исполняющиеся программы называются процессами. Процессы общаются с операционной системой и внешним миром с помощью системных вызовов. Сейчас расскажем как, но обо всём по порядку.

Как мы узнали в прошлом уроке, программа , запущенная пользователем без административных прав, не имеет доступа к режиму ядра ОС, то есть ко всему аппаратному оборудованию устройства и его программным возможностям, но, используя системные вызовы, программа может получить необходимые ресурсы от ОС, давайте более подробно рассмотрим этот процесс:

1.	Процесс выполняет системный вызов.
1.	Процессор делает прерывание и переходит в режим ядра.
1.	Ядро выполняет указанную системную функцию и возвращает управление процессу в пользовательском режиме.
1.	Процесс продолжает свое выполнение в пользовательском режиме.
   
Такой механизм позволяет ядру контролировать доступ к привилегированным операциям и ресурсам системы. Основные типы системных вызовов:

1. Создание процесса:
  fork: Создание нового процесса, путем копирования вызывающего процесса. Этот вызов может быть использован, например, для создания параллельных процессов или демонов.

2. Управление файлами:
   open, read, write, close: Они используются для работы с файлами - открытия, чтения, записи и закрытия файлов соответственно. Эти системные вызовы позволяют приложениям взаимодействовать с файловой системой.

3. Управление памятью:
   brk, mmap, munmap: Для управления памятью приложения используются эти системные вызовы. Например, mmap может использоваться для отображения файла в память для быстрого доступа.

4. Создание и управление потоками:
   clone, pthread_create: Эти системные вызовы используются для создания и управления потоками выполнения в многопоточных приложениях.

5. Создание и управление сетевыми соединениями:
   socket, bind, connect, send, recv: Для работы с сетевыми соединениями приложения используют эти системные вызовы. Например, socket используется для создания нового сокета.

6. Управление процессами:
   exec, kill, wait: Эти вызовы используются для управления процессами. Например, exec используется для замены текущего процесса новым процессом.

7. Управление устройствами ввода-вывода:
   ioctl: Данный вызов используется для управления устройствами ввода-вывода, например, чтения и установки параметров устройств.

В отличии от UNIX-подобных систем, таких как Linux или MacOS, где системные вызовы обычно реализованы через прерывания, В операционной системе Windows системные вызовы обычно выполняются через интерфейс API операционной системы. API (Интерфейс прикладного программирования) — это набор правил и методов, позволяющих различным программам взаимодействовать друг с другом.  При вызове API происходит переключение контекста из пользовательского режима в режим ядра, где происходит обработка запроса.

Стоит так же обратить внимание на то, что каждый системный вызов требует переключения контекста между пользовательским и ядерным уровнями, что вызывает некоторые накладные расходы. Оптимизации системных вызовов, такие как использование кэширования или асинхронных вызовов, могут повысить производительность. Так же неправильное использование системных вызовов(случайное или злонамеренное) может привести к уязвимостям безопасности. Например, некорректная обработка ввода-вывода файлов или недостаточная проверка разрешений при доступе к ресурсам может привести к утечкам данных или повышенным привилегиям.

## ПЗ

Какие системные вызовы выполняет программа для создания и записи в файл?

open, write, close

От системных вызовов перейдём к процессам, как к более крупной абстракции в ОС.

Процесс - это контейнер, внутри которого выполняется один экземпляр программы. 

Программа - это набор команд, написанных на языке программирования, чтобы компьютер мог понять, что делать. Эти команды объединяются в определенном порядке для выполнения конкретной задачи, будь то отображение веб-страницы, обработка изображений или сортировка данных. Когда программа выполняется, компьютер следует этим инструкциям, чтобы добиться нужного результата.

Процесс состоит из:

- адресного пространства
- потоков
- открытых файлов
- дочерних процессов

Каждый процесс имеет жизненный цикл. Различия в жизненном цикле процесса может быть связано с конкретной операционной системой, но общие этапы включают:

1. Создание (Creation): Процесс создается операционной системой, например, когда вы запускаете новую программу.
1. Готовность (Ready): Процесс ожидает своей очереди на выполнение.
1. Выполнение (Running): Процесс находится в процессе выполнения.
1. Ожидание (Waiting): Процесс ожидает завершения какого-то события, например, ввода-вывода или сигнала от другого процесса.
1. Завершение (Termination): Процесс завершается и освобождает выделенные ресурсы.

Изображение: тут можно круговое что-то, типа уробороса, только с обозначением циклов жизни процесса, например:

![3 1](https://github.com/lexche/Testyp/assets/95694325/f9d74248-bf22-4283-b009-80dca4ea53b6)

Кроме того, существуют также состояния, такие как «приостановлен», «зомби» и т.д., которые зависят от особенностей конкретной системы.

## ПЗ

# Тут у нас повтор со вторым уроком, заменил на "выбери несуществующее состояние процесса .

Какого состояния процесса не существует?

- Готовность. \Неверно
- Зомби. \Неверно
- Продолжение. \Верно
- Завершение. \Неверно

Так как же процессор успевает обработать все процессы? В первом уроке мы узнали, что ОС разделяются, в том числе, и по типу доступа к ресурсам. В настоящее время наиболее распространены ОС разделения времени (time-sharing). 

Операционные системы, поддерживающие time-sharing, используют планирование процессов для того, чтобы каждый процесс получил адекватную долю времени процессора для выполнения. Это позволяет создать впечатление параллельной работы множества процессов, даже если на самом деле процессор выполняет их поочередно.

Принципы работы time-sharing:
1. Планирование процессов: Операционная система использует алгоритмы планирования для распределения доступного процессорного времени между активными процессами. Это означает, что каждый процесс получает краткий промежуток времени для выполнения, прежде чем операционная система переключает контекст на следующий процесс.

2. Контекстное переключение: Когда операционная система переключает выполнение с одного процесса на другой, происходит контекстное переключение, при котором сохраняется состояние одного процесса, а затем загружается состояние другого процесса. 

3. Многозадачность: Time-sharing позволяет достичь многозадачности, т.е. впечатление одновременной работы нескольких процессов, даже несмотря на то, что процессор фактически последовательно выполняет их.

Таким образом, благодаря time-sharing операционная система старается обеспечить справедливое распределение процессорного времени и других ресурсов (оперативной памяти, дискового пространства) между множеством процессов, создавая впечатление одновременной работы. 

Изображение - иллюстрация time-sharing. Такая аналогия, можно ещё из комиксов Флэша приплести, он один, но из-за скорости может показаться, что его несколько и он везде успевает. Но аналогия со старой советской игрой нравится больше:

<p align="center">
  <img src="https://github.com/lexche/Testyp/assets/95694325/a6b6c7b2-9d83-4f2c-96e3-5249f3b7938e)" />
</p>

Давайте проговорим как ОС управляет процессами, так как описание time-sharing, хоть и даёт понимание про некоторые, но не раскрывает все инструменты управления:

- Создание процессов. При запуске программы ОС создаёт под неё процесс и выделяет ресурсы.
  
- Планирование выполнения. ОС отвечает за планирование выполнения процессов на процессоре. У нее есть специальный компонент, называемый планировщиком, который решает, какой процесс будет выполняться в данный момент времени. Планировщик учитывает приоритеты процессов, их состояние и другие факторы для эффективного распределения ресурсов процессора.
  
- Контроль за ресурсами. ОС контролирует доступ процессов к ресурсам, таким как память, файлы, устройства ввода-вывода и т.д. Она обеспечивает изоляцию процессов, чтобы они не могли чрезмерно вмешиваться в работу друг друга или повреждать ресурсы. Она также управляет конкуренцией за ресурсы и разрешает их конфликты.
  
- Межпроцессное взаимодействие. ОС предоставляет механизмы для межпроцессного взаимодействия, позволяющие процессам обмениваться данными, сигналами и событиями. Это может включать в себя разделяемую память, сигналы, каналы связи и сетевые соединения.
  
- Обработка сигналов и исключений. ОС отвечает за обработку сигналов и исключений, возникающих в процессах. Например, когда процесс пытается обратиться к недопустимой памяти, операционная система перехватывает исключение и обрабатывает его, чтобы предотвратить сбой самой системы.
  
- Завершение процессов. ОС обеспечивает контроль за завершением процессов, освобождая занимаемые ими ресурсы по завершении их работы. Она также обрабатывает окончание выполнения процессов, освобождая связанные с ними ресурсы и очищая информацию о завершенных процессах.

## ПЗ

Как система контролирует процессы?

-Контролирует ресурсы

-Создаёт процессы

-Контролирует сетевое подключение \Неверно

-Планирует выполнение

Не лишним будет ещё раз поговорить о безопасности в прошлом уроке мы рассмотрели только SELinux, но это не единственный инструмент.Рассмотрим, повторим, несколько из них:

1. SELinux (Security-Enhanced Linux). Это система мандатного управления доступом, которая добавляет дополнительные уровни безопасности к ядру Linux. SELinux внедряет концепцию мандатного управления доступом (MAC), что позволяет ему управлять доступом к файлам, памяти, устройствам и различным другим ресурсам на системе.
2. AppArmor - это ещё одна система мандатного управления безопасностью. Она разрабатывалась для ограничения возможностей программ, запущенных на системе Linux. AppArmor использует профили безопасности, которые позволяют определить правила доступа для конкретных программ, определяя, какие файлы, директории и ресурсы конкретная программа может использовать.
3. Integrity/IMA (Integrity Measurement Architecture) - это подсистема ядра Linux, которая предназначена для обеспечения целостности файлов в системе. Она позволяет создавать хэш-суммы для исполняемых файлов, библиотек и других системных файлов, и сохранять их в расширенных атрибутах файловой системы. Затем при загрузке системы или запуске приложений, IMA проверяет хэш-суммы файлов и сравнивает их с сохраненными значениями для обеспечения их целостности.
4. SecComp - это механизм контроля доступа в Linux, который позволяет ограничивать системные вызовы, доступные процессам в пользовательском пространстве. Это может быть использовано для создания "песочницы" для запуска приложений, ограничивая их возможности выполнения опасных действий.

Сегодня мы узнали для чего нужны системные вызовы, какие они бывают. Рассмотрели как осуществляются системные вызовы в разных ОС, их влияние на производительность и безопасность системы. Изучили что такое процесс, его жизненные циклы. Рассмотрели принцип time-sharing'a и о том как система управляет процессами. Изучили основные концепции управления процессами и безопасностью в ОС Linux.

