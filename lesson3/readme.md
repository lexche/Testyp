## Урок 3. Работа с файлами

В заключительном уроке этой темы мы поговорим о работе с файлами при помощи Python. Python взаимодействует с файлами с помощью встроенных функций и методов, которые обеспечивают различные операции чтения, записи и управления файлами. 

Ранее в этом курсе мы рассматривали дескрипторы файлов. Кратко напомним, дескриптор файла - это целое число, которое операционная система использует для идентификации открытого файла. Он представляет собой абстрактную ссылку на файл, позволяя программе взаимодействовать с ним.  

Он как шифр, который открывает доступ к файлу, не раскрывая его точное местоположение на компьютере. 

Как работают дескрипторы файлов:

1. Открытие файла: При обращении к файлу (чтение, запись, выполнение) операционная система проверяет наличие такого файла и, если он найден, создает дескриптор, который  "привязывается" к этому файлу. 

2. Использование дескриптора:  Дескриптор позволяет вам взаимодействовать с файлом, не зная его физического местоположения на диске.  Вы можете читать, записывать данные, менять атрибуты файла, используя только дескриптор.

3. Закрытие файла:  После завершения работы с файлом необходимо "отвязать" дескриптор от него. Это освобождает ресурсы системы и предотвращает нежелательные изменения файла.

Преимущества использования дескрипторов:

* Упрощение доступа к файлам: Программисту не нужно знать детали физического расположения файла на диске.

* Улучшенная безопасность:  Дескрипторы  делают доступ к файлам более безопасным, так как они не раскрывают  полный путь к файлу.

* Эффективное управление ресурсами:  Дескрипторы  помогают  оптимизировать  использование  файлов,  ограничивая  количество  открытых  файлов  одновременно.

В Python дескрипторы файлов используются "под капотом", и программист обычно не работает с ними напрямую. Python предоставляет более удобный и абстрактный способ работы с файлами через объекты file.

Рассмотрим основные функции в Python для работы с файлами:

#### 1. Функция open().

 Функция open() в Python используется для открытия файлов в различных режимах. Она позволяет читать, записывать и работать с содержимым файлов. Вот более подробное объяснение о функции open() с примерами:

 ```
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```

- file: имя файла или путь к файлу.
  
- mode: режим открытия файла. По умолчанию используется режим чтения r (read). Другие режимы :

r (Read) - Открывает файл только для чтения. Если файла не существует, возникнет ошибка FileNotFoundError.

w (Write) - Открывает файл для записи. Если файл не существует, он будет создан. Если файл уже существует, он будет перезаписан, и старые данные будут удалены.

a (Append) - Открывает файл для добавления данных. Если файл не существует, он будет создан. Если файл уже существует, новые данные будут добавлены в конец файла.

b (Binary) - Указывает, что файл нужно обрабатывать как бинарный. Используется в сочетании с другими режимами, например, rb (чтение бинарных файлов) и wb (запись бинарных файлов).

r+ (Read and Write) - Открывает файл для чтения и записи. Если файла не существует, возникнет ошибка FileNotFoundError.

w+ (Write and Read) - Открывает файл для чтения и записи. Если файла не существует, он будет создан. Если файл уже существует, он будет перезаписан.

a+ (Append and Read) - Открывает файл для чтения и записи. Если файла не существует, он будет создан. Если файл уже существует, новые данные будут добавлены в конец файла, а также можно будет читать данные из файла.

- buffering: параметр, который определяет размер буфера для чтения или записи. Если buffering=0, то буферизация будет отключена.

- encoding: кодировка файла.

- errors: способ обработки ошибок при чтении или записи файла.

- newline: перевод строки.

- closefd: указывает, следует ли закрывать файловый дескриптор при закрытии файла.

- opener: функция, которая будет использоваться для открытия файла.

#### 2. Функция read().

Функция read() в Python используется для чтения данных из файла. Она позволяет считать все содержимое файла целиком или заданное количество символов. Давайте рассмотрим подробнее функцию read() с примерами и объяснениями.

Функция read() считывает содержимое файла от текущей позиции курсора до конца файла или указанного количества символов.

Функция read() считывает содержимое файла от текущей позиции курсора до конца файла или указанного количества символов. Если ничего не указано в скобках, метод read() считывает все содержимое файла.

 После использования метода read(), курсор в файле перемещается в конец считанного участка.
 
Использование функции read() позволяет получить данные из файла и работать с ними в программе.

1. Пример с чтением всего содержимого файла:

```
# Открываем файл для чтения
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
```

- В этом примере открывается файл 'example.txt' в режиме чтения ('r').
- Метод read() вызывается для чтения всего содержимого файла и сохранения его в переменную content.
- Содержимое файла выводится на экран с помощью print().

2. Пример с чтением определенного количества символов из файла:

with open('example.txt', 'r') as file:
    content = file.read(10)
    print(content)

- Здесь метод read(10) используется для чтения первых 10 символов из файла.
- Только первые 10 символов файла будут считаны и сохранены в переменной content.


Важно учитывать, что при работе с большими файлами, чтение целиком содержимого файла в память может быть неэффективным. В таких случаях лучше использовать чтение файла построчно или поблочно. Функция read() удобна для работы с небольшими файлами, когда требуется прочитать все содержимое целиком.

#### 3. Функция write().

Функция write() в Python используется для записи данных в файл. Она принимает один аргумент - строку, которую нужно записать в файл. Функция write() осуществляет запись в файл оттуда, где находится указатель позиции в файле. Если указатель находится в начале файла, то данные будут записаны в начало файла, а если указатель находится в конце файла, то данные будут добавлены в конец файла.

Пример использования функции write() для записи строки в файл:

```
# Открываем файл для записи
f = open("example.txt", "w")

# Записываем строку в файл
f.write("Hello, world!")

# Закрываем файл
f.close()
```

В приведенном примере мы открываем файл "example.txt" для записи (режим "w"), далее используем функцию write() для записи строки "Hello, world!" в файл, и наконец закрываем файл.

Если файл уже существует и содержит какие-то данные, то при использовании функции write() данные будут перезаписаны. Если же нужно добавить данные в конец файла, не затирая уже существующие данные, то можно открыть файл в режиме "a" (append) вместо "w".

```
# Открываем файл для добавления данных
f = open("example.txt", "a")

# Добавляем строку в конец файла
f.write("\nThis is a new line.")

# Закрываем файл
f.close()
```

В данном примере мы открываем файл "example.txt" для добавления данных (режим "a"), используем функцию write() чтобы добавить строку "This is a new line." в файл, и затем закрываем файл.

Функция write() очень полезна при работе с файлами, так как позволяет записать данные в файл в процессе выполнения программы.

#### 4. Функция close().

Функция close() в Python используется для закрытия файлов или объектов, которые поддерживают операции ввода-вывода. После того, как файл или объект закрыт, нельзя будет совершать операции ввода-вывода с ним.

Функция close() используется для освобождения ресурсов, связанных с файлами или объектами ввода-вывода. После закрытия, использовать данный ресурс становится невозможно.

Когда файл или объект закрывается, операционная система освобождает все выделенные для него системные ресурсы.

Не закрывая файлы или соединения с базой данных после использования, можно столкнуться с проблемами в работе программы из-за утечек памяти или недоступности ресурсов.

Ниже представлены примеры и объяснения использования функции close():

1. Закрытие файла

```
file = open("example.txt", "r")
content = file.read()
print(content)
file.close()  # Закрываем файл
```

В данном примере мы открываем файл "example.txt" в режиме чтения ('r'), считываем его содержимое и выводим на экран. После завершения работы с файлом, мы закрываем его с помощью функции close().

2. Закрытие соединения с базой данных

```
import sqlite3

# Устанавливаем соединение с базой данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Выполняем какие-то операции с базой данных

conn.commit()
conn.close()  # Закрываем соединение с базой данных
```

В этом примере мы используем модуль sqlite3 для работы с базой данных SQLite. Мы устанавливаем соединение с базой данных, выполняем какие-то операции и затем закрываем соединение с помощью close().

Важно правильно использовать функцию close() после окончания работы с файлами или объектами, чтобы избежать возможных проблем с ресурсами.

### Практическое задание

Представьте, что у вас есть некий логфайл, который хранится в файле log.txt:

```
2023-10-27 10:15:32 INFO: Starting application...
2023-10-27 10:15:32 DEBUG: Loading configuration file...
2023-10-27 10:15:33 INFO: Configuration file loaded successfully.
2023-10-27 10:15:33 DEBUG: Connecting to database...
2023-10-27 10:15:34 INFO: Database connection established.
2023-10-27 10:15:34 WARNING: Some database tables are outdated.
2023-10-27 10:15:34 DEBUG: Checking for updates...
2023-10-27 10:15:35 INFO: Database updated successfully.
2023-10-27 10:15:35 DEBUG: Starting main process...
2023-10-27 10:15:35 INFO: Main process started.
2023-10-27 10:15:36 DEBUG: Processing request 1...
2023-10-27 10:15:37 INFO: Request 1 processed successfully.
2023-10-27 10:15:37 DEBUG: Processing request 2...
2023-10-27 10:15:38 INFO: Request 2 processed successfully.
2023-10-27 10:15:38 DEBUG: Processing request 3...
2023-10-27 10:15:39 INFO: Request 3 processed successfully.
2023-10-27 10:15:39 DEBUG: Processing request 4...
2023-10-27 10:15:40 INFO: Request 4 processed successfully.
2023-10-27 10:15:40 DEBUG: Processing request 5...
2023-10-27 10:15:41 INFO: Request 5 processed successfully.
2023-10-27 10:15:41 DEBUG: Processing request 6...
2023-10-27 10:15:42 INFO: Request 6 processed successfully.
2023-10-27 10:15:42 DEBUG: Processing request 7...
2023-10-27 10:15:43 INFO: Request 7 processed successfully.
2023-10-27 10:15:43 DEBUG: Processing request 8...
2023-10-27 10:15:44 INFO: Request 8 processed successfully.
2023-10-27 10:15:44 DEBUG: Processing request 9...
2023-10-27 10:15:45 INFO: Request 9 processed successfully.
2023-10-27 10:15:45 DEBUG: Processing request 10...
2023-10-27 10:15:46 INFO: Request 10 processed successfully.
2023-10-27 10:15:46 DEBUG: Processing request 11...
2023-10-27 10:15:47 INFO: Request 11 processed successfully.
2023-10-27 10:15:47 DEBUG: Processing request 12...
2023-10-27 10:15:48 INFO: Request 12 processed successfully.
2023-10-27 10:15:48 DEBUG: Processing request 13...
2023-10-27 10:15:49 INFO: Request 13 processed successfully.
2023-10-27 10:15:49 DEBUG: Processing request 14...
2023-10-27 10:15:50 INFO: Request 14 processed successfully.
2023-10-27 10:15:50 DEBUG: Processing request 15...
2023-10-27 10:15:51 INFO: Request 15 processed successfully.
2023-10-27 10:15:51 DEBUG: Processing request 16...
2023-10-27 10:15:52 INFO: Request 16 processed successfully.
2023-10-27 10:15:52 DEBUG: Processing request 17...
2023-10-27 10:15:53 INFO: Request 17 processed successfully.
2023-10-27 10:15:53 DEBUG: Processing request 18...
2023-10-27 10:15:54 INFO: Request 18 processed successfully.
2023-10-27 10:15:54 DEBUG: Processing request 19...
2023-10-27 10:15:55 INFO: Request 19 processed successfully.
2023-10-27 10:15:55 DEBUG: Processing request 20...
2023-10-27 10:15:56 INFO: Request 20 processed successfully.
2023-10-27 10:15:56 DEBUG: Shutting down application...
2023-10-27 10:15:57 INFO: Application shut down successfully.
```
 Вам нужно написать скрипт, который оставит в этом лог файле только события Debug c 10:15:40 до 10:15:50.

 Вам немного повезло, у вас в распоряжении есть скрипт с пояснениями, который оставляет только события Info:

 ```
import re
    """
   Импортируется модуль регулярных выражений для работы с текстовыми данными. Это позволяет использовать регулярные выражения в скрипте.
    """

def read_log_data(filename):
    """
    объявляется функция read_log_data(filename), которая будет читать данные из лог-файла и возвращать список строк. 
    """
    with open(filename, 'r', encoding='utf-8') as f:
    """
    открывается файл filename для чтения текста с указанным кодированием (utf-8). Файл связывается с переменной f в контексте      with, который автоматически закроет файл после завершения работы.
    """
        data = f.readlines()
     """
     данные из файла считываются и сохраняются в переменную data в виде списка строк.
     """
    return data
    """
    список строк возвращается после чтения данных из файла.
    """

def write_processed_log(filename, processed_data):
    """
    Функция записывает обработанные данные в лог-файл.
    """
    with open(filename, 'w', encoding='utf-8') as f:
    """
     открывается файл filename для записи текста с указанным кодированием (utf-8). Файл связывается с переменной f в контексте      with, который автоматически закроет файл после завершения работы.
    """
        f.writelines(processed_data)

def process_log(filename):
    """
    Основная функция, которая обрабатывает данные из лог-файла.
    """
    log_data = read_log_data(filename)

    # Обработка данных:  извлечение только строк с уровнем "INFO"
    processed_data = []
    for line in log_data:
        if re.search(r'^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} INFO:', line):
            processed_data.append(line)

    write_processed_log(filename, processed_data)

if __name__ == '__main__':
    log_filename = 'log.txt'  # Имя лог-файла
    process_log(log_filename)  # Вызов функции обработки лога

```
Решение автора:

```

import re

def read_log_data(filename):
    """
    Функция читает данные из лог-файла и возвращает список строк.
    """
    with open(filename, 'r', encoding='utf-8') as f:
        data = f.readlines()
    return data

def write_processed_log(filename, processed_data):
    """
    Функция записывает обработанные данные в лог-файл.
    """
    with open(filename, 'w', encoding='utf-8') as f:
        f.writelines(processed_data)

def process_log(filename):
    """
    Основная функция, которая обрабатывает данные из лог-файла.
    """
    log_data = read_log_data(filename)

    # Обработка данных:  извлечение только строк с уровнем "DEBUG" 
    # в промежутке времени с 10:15:40 до 10:15:50
    processed_data = []
    for line in log_data:
        if re.search(r'^[0-9]{4}-[0-9]{2}-[0-9]{2} 10:15:[4][0-9] DEBUG:', line) or \
           re.search(r'^[0-9]{4}-[0-9]{2}-[0-9]{2} 10:15:50 DEBUG:', line):
            processed_data.append(line)

    write_processed_log(filename, processed_data)

if __name__ == '__main__':
    log_filename = 'log.txt'  # Имя лог-файла
    process_log(log_filename)  # Вызов функции обработки лога

```

### Квиз

Вопрос 1: 
Какое действие произойдет, если вы откроете файл в Python, но не закроете его перед выходом из программы?

a) Файл будет автоматически закрыт операционной системой.
b) Файл останется открытым и может быть доступен другим процессам.
c) Файл будет автоматически удален.
d) Ничего не произойдет.

Объяснение: 
Правильный ответ: b) 
Если файл не закрыт перед выходом из программы, он останется открытым. Это может привести к проблемам, если другой процесс попытается получить к нему доступ, например, для записи или удаления.

Вопрос 2: 
Какая функция в Python используется для закрытия файла?

a) close()
b) exit()
c) delete()
d) save()

Объяснение: 
Правильный ответ: a) 
Функция close() используется для закрытия файла, освобождая его для других процессов.

Вопрос 3: 
Какой режим открытия файла используется для записи данных в конец существующего файла?

a) r
b) w
c) a
d) x

Объяснение: 
Правильный ответ: c) 
Режим a (append) открывает файл для дозаписи. Новые данные будут добавлены в конец файла.

Вопрос 4: 
Что произойдет, если вы попытаетесь открыть файл для записи ('w') в режиме чтения ('r') ?

a) Файл будет открыт в режиме чтения.
b) Файл будет открыт в режиме записи.
c) Программа завершится с ошибкой.
d) Файл будет создан.

Объяснение: 
Правильный ответ: c) 
Программа завершится с ошибкой, так как режим открытия файла не совпадает с заданным режимом работы. 
