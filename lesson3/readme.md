## Урок 3. Работа с файлами

В заключительном уроке этой темы мы поговорим о работе с файлами при помощи Python. Python взаимодействует с файлами с помощью встроенных функций и методов, которые обеспечивают различные операции чтения, записи и управления файлами. 

Ранее в этом курсе мы рассматривали дескрипторы файлов. Кратко напомним, дескриптор файла - это целое число, которое операционная система использует для идентификации открытого файла. Он представляет собой абстрактную ссылку на файл, позволяя программе взаимодействовать с ним.  

Он как шифр, который открывает доступ к файлу, не раскрывая его точное местоположение на компьютере. 

Как работают дескрипторы файлов:

1. Открытие файла: При обращении к файлу (чтение, запись, выполнение) операционная система проверяет наличие такого файла и, если он найден, создает дескриптор, который  "привязывается" к этому файлу. 

2. Использование дескриптора:  Дескриптор позволяет вам взаимодействовать с файлом, не зная его физического местоположения на диске.  Вы можете читать, записывать данные, менять атрибуты файла, используя только дескриптор.

3. Закрытие файла:  После завершения работы с файлом необходимо "отвязать" дескриптор от него. Это освобождает ресурсы системы и предотвращает нежелательные изменения файла.

Преимущества использования дескрипторов:

* Упрощение доступа к файлам: Программисту не нужно знать детали физического расположения файла на диске.

* Улучшенная безопасность:  Дескрипторы  делают доступ к файлам более безопасным, так как они не раскрывают  полный путь к файлу.

* Эффективное управление ресурсами:  Дескрипторы  помогают  оптимизировать  использование  файлов,  ограничивая  количество  открытых  файлов  одновременно.

В Python дескрипторы файлов используются "под капотом", и программист обычно не работает с ними напрямую. Python предоставляет более удобный и абстрактный способ работы с файлами через объекты file.

Рассмотрим основные функции в Python для работы с файлами:

#### 1. Функция open().

 Функция open() в Python используется для открытия файлов в различных режимах. Она позволяет читать, записывать и работать с содержимым файлов. Вот более подробное объяснение о функции open() с примерами:

 ```
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```

- file: имя файла или путь к файлу.
  
- mode: режим открытия файла. По умолчанию используется режим чтения r (read). Другие режимы :

r (Read) - Открывает файл только для чтения. Если файла не существует, возникнет ошибка FileNotFoundError.

w (Write) - Открывает файл для записи. Если файл не существует, он будет создан. Если файл уже существует, он будет перезаписан, и старые данные будут удалены.

a (Append) - Открывает файл для добавления данных. Если файл не существует, он будет создан. Если файл уже существует, новые данные будут добавлены в конец файла.

b (Binary) - Указывает, что файл нужно обрабатывать как бинарный. Используется в сочетании с другими режимами, например, rb (чтение бинарных файлов) и wb (запись бинарных файлов).

r+ (Read and Write) - Открывает файл для чтения и записи. Если файла не существует, возникнет ошибка FileNotFoundError.

w+ (Write and Read) - Открывает файл для чтения и записи. Если файла не существует, он будет создан. Если файл уже существует, он будет перезаписан.

a+ (Append and Read) - Открывает файл для чтения и записи. Если файла не существует, он будет создан. Если файл уже существует, новые данные будут добавлены в конец файла, а также можно будет читать данные из файла.

- buffering: параметр, который определяет размер буфера для чтения или записи. Если buffering=0, то буферизация будет отключена.

- encoding: кодировка файла.

- errors: способ обработки ошибок при чтении или записи файла.

- newline: перевод строки.

- closefd: указывает, следует ли закрывать файловый дескриптор при закрытии файла.

- opener: функция, которая будет использоваться для открытия файла.

#### 2. Функция read().

Функция read() в Python используется для чтения данных из файла. Она позволяет считать все содержимое файла целиком или заданное количество символов. Давайте рассмотрим подробнее функцию read() с примерами и объяснениями.

Функция read() считывает содержимое файла от текущей позиции курсора до конца файла или указанного количества символов.

Функция read() считывает содержимое файла от текущей позиции курсора до конца файла или указанного количества символов. Если ничего не указано в скобках, метод read() считывает все содержимое файла.

 После использования метода read(), курсор в файле перемещается в конец считанного участка.
 
Использование функции read() позволяет получить данные из файла и работать с ними в программе.

1. Пример с чтением всего содержимого файла:

```
# Открываем файл для чтения
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
```

- В этом примере открывается файл 'example.txt' в режиме чтения ('r').
- Метод read() вызывается для чтения всего содержимого файла и сохранения его в переменную content.
- Содержимое файла выводится на экран с помощью print().

2. Пример с чтением определенного количества символов из файла:

with open('example.txt', 'r') as file:
    content = file.read(10)
    print(content)

- Здесь метод read(10) используется для чтения первых 10 символов из файла.
- Только первые 10 символов файла будут считаны и сохранены в переменной content.


Важно учитывать, что при работе с большими файлами, чтение целиком содержимого файла в память может быть неэффективным. В таких случаях лучше использовать чтение файла построчно или поблочно. Функция read() удобна для работы с небольшими файлами, когда требуется прочитать все содержимое целиком.

#### 3. Функция write().

Функция write() в Python используется для записи данных в файл. Она принимает один аргумент - строку, которую нужно записать в файл. Функция write() осуществляет запись в файл оттуда, где находится указатель позиции в файле. Если указатель находится в начале файла, то данные будут записаны в начало файла, а если указатель находится в конце файла, то данные будут добавлены в конец файла.

Пример использования функции write() для записи строки в файл:

```
# Открываем файл для записи
f = open("example.txt", "w")

# Записываем строку в файл
f.write("Hello, world!")

# Закрываем файл
f.close()
```

В приведенном примере мы открываем файл "example.txt" для записи (режим "w"), далее используем функцию write() для записи строки "Hello, world!" в файл, и наконец закрываем файл.

Если файл уже существует и содержит какие-то данные, то при использовании функции write() данные будут перезаписаны. Если же нужно добавить данные в конец файла, не затирая уже существующие данные, то можно открыть файл в режиме "a" (append) вместо "w".

```
# Открываем файл для добавления данных
f = open("example.txt", "a")

# Добавляем строку в конец файла
f.write("\nThis is a new line.")

# Закрываем файл
f.close()
```

В данном примере мы открываем файл "example.txt" для добавления данных (режим "a"), используем функцию write() чтобы добавить строку "This is a new line." в файл, и затем закрываем файл.

Функция write() очень полезна при работе с файлами, так как позволяет записать данные в файл в процессе выполнения программы.

#### 4. Функция close().

Функция close() в Python используется для закрытия файлов или объектов, которые поддерживают операции ввода-вывода. После того, как файл или объект закрыт, нельзя будет совершать операции ввода-вывода с ним.

Функция close() используется для освобождения ресурсов, связанных с файлами или объектами ввода-вывода. После закрытия, использовать данный ресурс становится невозможно.

Когда файл или объект закрывается, операционная система освобождает все выделенные для него системные ресурсы.

Не закрывая файлы или соединения с базой данных после использования, можно столкнуться с проблемами в работе программы из-за утечек памяти или недоступности ресурсов.

Ниже представлены примеры и объяснения использования функции close():

1. Закрытие файла

```
file = open("example.txt", "r")
content = file.read()
print(content)
file.close()  # Закрываем файл
```

В данном примере мы открываем файл "example.txt" в режиме чтения ('r'), считываем его содержимое и выводим на экран. После завершения работы с файлом, мы закрываем его с помощью функции close().

2. Закрытие соединения с базой данных

```
import sqlite3

# Устанавливаем соединение с базой данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Выполняем какие-то операции с базой данных

conn.commit()
conn.close()  # Закрываем соединение с базой данных
```

В этом примере мы используем модуль sqlite3 для работы с базой данных SQLite. Мы устанавливаем соединение с базой данных, выполняем какие-то операции и затем закрываем соединение с помощью close().

Важно правильно использовать функцию close() после окончания работы с файлами или объектами, чтобы избежать возможных проблем с ресурсами.

### Практическое задание

Представьте, что у вас есть некий логфайл, который хранится в файле log.txt:

```
2023-10-27 10:15:32 INFO: Starting application...
2023-10-27 10:15:32 DEBUG: Loading configuration file...
2023-10-27 10:15:33 INFO: Configuration file loaded successfully.
2023-10-27 10:15:33 DEBUG: Connecting to database...
2023-10-27 10:15:34 INFO: Database connection established.
2023-10-27 10:15:34 WARNING: Some database tables are outdated.
2023-10-27 10:15:34 DEBUG: Checking for updates...
2023-10-27 10:15:35 INFO: Database updated successfully.
2023-10-27 10:15:35 DEBUG: Starting main process...
2023-10-27 10:15:35 INFO: Main process started.
2023-10-27 10:15:36 DEBUG: Processing request 1...
2023-10-27 10:15:37 INFO: Request 1 processed successfully.
2023-10-27 10:15:37 DEBUG: Processing request 2...
2023-10-27 10:15:38 INFO: Request 2 processed successfully.
2023-10-27 10:15:38 DEBUG: Processing request 3...
2023-10-27 10:15:39 INFO: Request 3 processed successfully.
2023-10-27 10:15:39 DEBUG: Processing request 4...
2023-10-27 10:15:40 INFO: Request 4 processed successfully.
2023-10-27 10:15:40 DEBUG: Processing request 5...
2023-10-27 10:15:41 INFO: Request 5 processed successfully.
2023-10-27 10:15:41 DEBUG: Processing request 6...
2023-10-27 10:15:42 INFO: Request 6 processed successfully.
2023-10-27 10:15:42 DEBUG: Processing request 7...
2023-10-27 10:15:43 INFO: Request 7 processed successfully.
2023-10-27 10:15:43 DEBUG: Processing request 8...
2023-10-27 10:15:44 INFO: Request 8 processed successfully.
2023-10-27 10:15:44 DEBUG: Processing request 9...
2023-10-27 10:15:45 INFO: Request 9 processed successfully.
2023-10-27 10:15:45 DEBUG: Processing request 10...
2023-10-27 10:15:46 INFO: Request 10 processed successfully.
2023-10-27 10:15:46 DEBUG: Processing request 11...
2023-10-27 10:15:47 INFO: Request 11 processed successfully.
2023-10-27 10:15:47 DEBUG: Processing request 12...
2023-10-27 10:15:48 INFO: Request 12 processed successfully.
2023-10-27 10:15:48 DEBUG: Processing request 13...
2023-10-27 10:15:49 INFO: Request 13 processed successfully.
2023-10-27 10:15:49 DEBUG: Processing request 14...
2023-10-27 10:15:50 INFO: Request 14 processed successfully.
2023-10-27 10:15:50 DEBUG: Processing request 15...
2023-10-27 10:15:51 INFO: Request 15 processed successfully.
2023-10-27 10:15:51 DEBUG: Processing request 16...
2023-10-27 10:15:52 INFO: Request 16 processed successfully.
2023-10-27 10:15:52 DEBUG: Processing request 17...
2023-10-27 10:15:53 INFO: Request 17 processed successfully.
2023-10-27 10:15:53 DEBUG: Processing request 18...
2023-10-27 10:15:54 INFO: Request 18 processed successfully.
2023-10-27 10:15:54 DEBUG: Processing request 19...
2023-10-27 10:15:55 INFO: Request 19 processed successfully.
2023-10-27 10:15:55 DEBUG: Processing request 20...
2023-10-27 10:15:56 INFO: Request 20 processed successfully.
2023-10-27 10:15:56 DEBUG: Shutting down application...
2023-10-27 10:15:57 INFO: Application shut down successfully.
```
 Вам нужно написать скрипт, который оставит в этом лог файле только события Debug c 10:15:40 до 10:15:50.

 Вам немного повезло, у вас в распоряжении есть скрипт с пояснениями, который оставляет только события Info:

 ```
import re
    """
   Импортируется модуль регулярных выражений для работы с текстовыми данными. Это позволяет использовать регулярные выражения в скрипте.
    """

def read_log_data(filename):
    """
    объявляется функция read_log_data(filename), которая будет читать данные из лог-файла и возвращать список строк. 
    """
    with open(filename, 'r', encoding='utf-8') as f:
    """
    открывается файл filename для чтения текста с указанным кодированием (utf-8). Файл связывается с переменной f в контексте      with, который автоматически закроет файл после завершения работы.
    """
        data = f.readlines()
     """
     данные из файла считываются и сохраняются в переменную data в виде списка строк.
     """
    return data
    """
    список строк возвращается после чтения данных из файла.
    """

def write_processed_log(filename, processed_data):
    """
    Функция записывает обработанные данные в лог-файл.
    """
    with open(filename, 'w', encoding='utf-8') as f:
    """
     открывается файл filename для записи текста с указанным кодированием (utf-8). Файл связывается с переменной f в контексте      with, который автоматически закроет файл после завершения работы.
    """
        f.writelines(processed_data)

def process_log(filename):
    """
    Основная функция, которая обрабатывает данные из лог-файла.
    """
    log_data = read_log_data(filename)

    # Обработка данных:  извлечение только строк с уровнем "INFO"
    processed_data = []
    for line in log_data:
        if re.search(r'^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} INFO:', line):
            processed_data.append(line)

    write_processed_log(filename, processed_data)

if __name__ == '__main__':
    log_filename = 'log.txt'  # Имя лог-файла
    process_log(log_filename)  # Вызов функции обработки лога

```
Решение автора:

```

import re

def read_log_data(filename):
    """
    Функция читает данные из лог-файла и возвращает список строк.
    """
    with open(filename, 'r', encoding='utf-8') as f:
        data = f.readlines()
    return data

def write_processed_log(filename, processed_data):
    """
    Функция записывает обработанные данные в лог-файл.
    """
    with open(filename, 'w', encoding='utf-8') as f:
        f.writelines(processed_data)

def process_log(filename):
    """
    Основная функция, которая обрабатывает данные из лог-файла.
    """
    log_data = read_log_data(filename)

    # Обработка данных:  извлечение только строк с уровнем "DEBUG" 
    # в промежутке времени с 10:15:40 до 10:15:50
    processed_data = []
    for line in log_data:
        if re.search(r'^[0-9]{4}-[0-9]{2}-[0-9]{2} 10:15:[4][0-9] DEBUG:', line) or \
           re.search(r'^[0-9]{4}-[0-9]{2}-[0-9]{2} 10:15:50 DEBUG:', line):
            processed_data.append(line)

    write_processed_log(filename, processed_data)

if __name__ == '__main__':
    log_filename = 'log.txt'  # Имя лог-файла
    process_log(log_filename)  # Вызов функции обработки лога

```

### Квиз

Вопрос 1: Какое действие произойдет, если вы откроете файл в Python, но не закроете его перед выходом из программы?

a) Файл будет автоматически закрыт операционной системой.

b) Файл останется открытым.

c) Файл будет автоматически удален.

d) Ничего не произойдет.

Правильный ответ: b). Если файл не закрыт перед выходом из программы, он останется открытым. Это может привести к проблемам, если другой процесс попытается получить к нему доступ.

Вопрос 2: Какая функция в Python используется для закрытия файла?

a) close()

b) exit()

c) delete()

d) save()

Правильный ответ: a). Функция close() используется для закрытия файла, освобождая его для других процессов.

Вопрос 3: Какой режим открытия файла используется для записи данных в конец существующего файла?

a) r

b) w

c) a

d) x

Правильный ответ: c). Режим a (append) открывает файл для дозаписи. Новые данные будут добавлены в конец файла.

Вопрос 4: Что произойдет, если вы попытаетесь открыть файл для записи ('w') в режиме чтения ('r') ?

a) Файл будет открыт в режиме чтения.

b) Файл будет открыт в режиме записи.

c) Программа завершится с ошибкой.

d) Файл будет создан.

Правильный ответ: c). Программа завершится с ошибкой, так как режим открытия файла не совпадает с заданным режимом работы. 

---

Разобранный в практическом задании пример хорошо работает когда нужно обработать небольшое количество данных, но в случае если у нас этих строк  миллионы, ресурсов компьютера может не хватить. В таких случаях эффективнее "читать" частями.

Разберём обработку больших файлов и использование контекстных менеджеров с with и yeld для управления файловыми потоками. 

Контекстные менеджеры в Python — это способ автоматизации действий, которые должны быть выполнены до и после блока кода. Они обеспечивают безопасный подход к работе с ресурсами, такими как файлы, соединения с базами данных или сетевые сокеты.

Ключевые особенности контекстных менеджеров:

* Автоматическое управление ресурсами: Контекстные менеджеры гарантируют, что ресурсы будут освобождены после завершения работы с ними, даже если возникнет ошибка.
* Повышение читаемости кода:  Использование контекстных менеджеров делает код более лаконичным и понятным, так как код управления ресурсами отделяется от основной логики.
* Обеспечение безопасности:  Контекстные менеджеры помогают избежать утечки ресурсов, что может привести к проблемам с производительностью и стабильностью.

Синтаксис:

Контекстные менеджеры используют ключевое слово with. 

```
with <объект_контекстного_менеджера> as <имя_переменной>:
    # Блок кода, который будет выполняться в контексте
    # менеджера
```

Пример использования:

```
# Открытие файла с использованием контекстного менеджера
with open('my_file.txt', 'r') as f:
    data = f.read()
    print(data)

# Соединение с базой данных с использованием контекстного менеджера
import sqlite3
with sqlite3.connect('my_database.db') as conn:
    cursor = conn.cursor()
    # Выполнение SQL-запросов
```

Как работают контекстные менеджеры:

1. Вхождение в контекст: При входе в блок with выполняется метод __enter__ контекстного менеджера. 
2. Выполнение кода: В блоке with выполняется ваш код, работающий с ресурсом.
3. Выход из контекста: После выхода из блока with, независимо от того, произошла ошибка или нет, выполняется метод __exit__ контекстного менеджера. Этот метод освобождает ресурс.

Преимущества использования контекстных менеджеров:

* Повышение надежности: Автоматическое освобождение ресурсов предотвращает утечки и ошибки.
* Улучшение читаемости:  Код становится более лаконичным и структурированным.
* Упрощение работы с ресурсами:  Контекстные менеджеры скрывают детали управления ресурсами.

with - это ключевое слово в Python, которое используется для работы с контекстными менеджерами. with в Python обеспечивает  "безопасное" использование ресурсов, гарантируя, что они будут правильно "закрыты" после использования. 

Как работает with:

1. Вхождение:  Ты "входишь" в блок with - это как вход в библиотеку.
2. Использование ресурса: Внутри блока with ты используешь ресурс, например, открываешь файл. 
3. Выход: Когда ты выходишь из блока with, ресурс автоматически "закрывается" - как если бы ты возвращал книгу на место. 

Преимущества with:

* Автоматическое закрытие ресурсов:  Тебе не нужно вручную "закрывать" ресурсы, такие как файлы, соединения, блокировки и т.д. with делает это за тебя.
* Обработка ошибок:  with гарантирует, что ресурсы будут закрыты даже в случае возникновения ошибок в коде.
* Простота:  with делает код более читаемым и лаконичным, избавляя от необходимости вручную вызывать методы для открытия и закрытия ресурсов.

Важно:

with работает с объектами, которые реализуют протокол контекстного менеджера, который определяет методы __enter__ и __exit__. 

В общем:

with - это простой и удобный способ управлять ресурсами в Python, делая код более безопасным и читаемым.

Перейдём к yield.

Представь себе, что ты печешь печенье. Тебе нужно много печенья, но у тебя есть только один противень. Что ты делаешь? Ты печешь одну партию, достаешь ее из духовки, а затем печешь следующую. 

yield в Python работает примерно так же.  Это как противень в нашей пекарне – он позволяет тебе "печь" значения в функции по одному, не загружая всю "партию" сразу. 

Как работает yield:

1. Функция-генератор: Ты создаешь функцию, которая содержит yield внутри.
2. Первое вызов: Когда ты вызываешь функцию, она "печет" первое значение и возвращает его с помощью yield.
3. Пауза: После yield функция не завершается, а "останавливается" там, где она была.
4. Следующий вызов: Когда ты снова вызываешь функцию (например, в цикле), она "запускается" с места, где остановилась, и "печет" следующее значение. 

Преимущества yield:

* Эффективная память: Ты не создаешь список всех значений сразу, а генерируешь их по одному, экономя память.
* Бесконечные последовательности: Ты можешь генерировать бесконечное количество значений. 
* Простота:  yield упрощает создание итераторов, которые генерируют значения по мере необходимости.

Пример:
```
def my_generator(n):
    for i in range(n):
        yield i * 2 

for number in my_generator(5):
    print(number) 
```

В этом коде:

1.  my_generator - это функция-генератор.
2.  yield i * 2 - это "пекарня", которая "печет" значения (четные числа от 0 до 8).
3.  for number in my_generator(5) - это цикл, который "ест" печенье по одному. 

Важно: yield не просто "возвращает" значение, а "паузирует" функцию до следующего вызова.

Давайте разберём пример, в котором мы обработаем лог-файл по частям с помощью with и yield:

```
def process_log_file(filename):
    """Генератор, который читает файл лога построчно и обрабатывает каждую строку."""
    with open(filename, 'r') as log_file:
        for line in log_file:
            # Обрабатываем каждую строку (например, парсим, анализируем)
            yield process_log_line(line)  # Возвращаем результат обработки строки

def process_log_line(line):
    """Функция, которая обрабатывает строку из лога."""
    # Добавьте свою логику обработки строки здесь
    # Например, разделение строки по пробелам, поиск ошибок
    parts = line.split()
    if 'ERROR' in parts:
        print(f"Найдена ошибка: {line.strip()}")
    return parts

# Используем генератор для обработки файла лога
for processed_line in process_log_file('my_big_log.txt'):
    # Обрабатываем каждую обработанную строку
    print(f"Обработанная строка: {processed_line}")

```

Объяснение:

1. process_log_file:
   - Эта функция - генератор, благодаря yield. 
   - Она открывает файл лога с помощью with, что гарантирует закрытие файла, даже если возникнет ошибка.
   - Цикл for проходит по каждой строке файла.
   - Для каждой строки вызывается функция process_log_line. 
   - Результат process_log_line передается yield, т.е. "возвращается" как часть генератора.

2. process_log_line:
   - Эта функция обрабатывает одну строку из лога. 
   - Здесь вы можете добавить вашу логику анализа, парсинга, поиска ошибок и т.д.
   - В этом примере мы просто ищем слово "ERROR" и печатаем строку, если оно найдено.

3. Использование генератора:
   - for processed_line in process_log_file('my_big_log.txt'): 
     - Цикл "проходит" по генератору process_log_file и получает каждую обработанную строку. 
     - Это позволяет обрабатывать файл построчно, не загружая его целиком в память.


   #### Практическое задание

Возьмите лог-файл и задание из предыдущего ПЗ и перепишите скрипт, используя while и yield, чтобы не было совсем скучно, запишите результат в новый файл new_log.txt. То есть из лог-файла:

   ```
2023-10-27 10:15:32 INFO: Starting application...
2023-10-27 10:15:32 DEBUG: Loading configuration file...
2023-10-27 10:15:33 INFO: Configuration file loaded successfully.
2023-10-27 10:15:33 DEBUG: Connecting to database...
2023-10-27 10:15:34 INFO: Database connection established.
2023-10-27 10:15:34 WARNING: Some database tables are outdated.
2023-10-27 10:15:34 DEBUG: Checking for updates...
2023-10-27 10:15:35 INFO: Database updated successfully.
2023-10-27 10:15:35 DEBUG: Starting main process...
2023-10-27 10:15:35 INFO: Main process started.
2023-10-27 10:15:36 DEBUG: Processing request 1...
2023-10-27 10:15:37 INFO: Request 1 processed successfully.
2023-10-27 10:15:37 DEBUG: Processing request 2...
2023-10-27 10:15:38 INFO: Request 2 processed successfully.
2023-10-27 10:15:38 DEBUG: Processing request 3...
2023-10-27 10:15:39 INFO: Request 3 processed successfully.
2023-10-27 10:15:39 DEBUG: Processing request 4...
2023-10-27 10:15:40 INFO: Request 4 processed successfully.
2023-10-27 10:15:40 DEBUG: Processing request 5...
2023-10-27 10:15:41 INFO: Request 5 processed successfully.
2023-10-27 10:15:41 DEBUG: Processing request 6...
2023-10-27 10:15:42 INFO: Request 6 processed successfully.
2023-10-27 10:15:42 DEBUG: Processing request 7...
2023-10-27 10:15:43 INFO: Request 7 processed successfully.
2023-10-27 10:15:43 DEBUG: Processing request 8...
2023-10-27 10:15:44 INFO: Request 8 processed successfully.
2023-10-27 10:15:44 DEBUG: Processing request 9...
2023-10-27 10:15:45 INFO: Request 9 processed successfully.
2023-10-27 10:15:45 DEBUG: Processing request 10...
2023-10-27 10:15:46 INFO: Request 10 processed successfully.
2023-10-27 10:15:46 DEBUG: Processing request 11...
2023-10-27 10:15:47 INFO: Request 11 processed successfully.
2023-10-27 10:15:47 DEBUG: Processing request 12...
2023-10-27 10:15:48 INFO: Request 12 processed successfully.
2023-10-27 10:15:48 DEBUG: Processing request 13...
2023-10-27 10:15:49 INFO: Request 13 processed successfully.
2023-10-27 10:15:49 DEBUG: Processing request 14...
2023-10-27 10:15:50 INFO: Request 14 processed successfully.
2023-10-27 10:15:50 DEBUG: Processing request 15...
2023-10-27 10:15:51 INFO: Request 15 processed successfully.
2023-10-27 10:15:51 DEBUG: Processing request 16...
2023-10-27 10:15:52 INFO: Request 16 processed successfully.
2023-10-27 10:15:52 DEBUG: Processing request 17...
2023-10-27 10:15:53 INFO: Request 17 processed successfully.
2023-10-27 10:15:53 DEBUG: Processing request 18...
2023-10-27 10:15:54 INFO: Request 18 processed successfully.
2023-10-27 10:15:54 DEBUG: Processing request 19...
2023-10-27 10:15:55 INFO: Request 19 processed successfully.
2023-10-27 10:15:55 DEBUG: Processing request 20...
2023-10-27 10:15:56 INFO: Request 20 processed successfully.
2023-10-27 10:15:56 DEBUG: Shutting down application...
2023-10-27 10:15:57 INFO: Application shut down successfully.
```
 Вам нужно написать скрипт, который оставит в этом лог файле только события Debug c 10:15:40 до 10:15:50 в файл new_log.txt, используя while и yield.

Решение автора:

```
import re

def process_log_file(filename):
    """Генератор, который читает файл лога построчно и обрабатывает каждую строку."""
    with open(filename, 'r', encoding='utf-8') as log_file:
        for line in log_file:
            if re.search(r'^[0-9]{4}-[0-9]{2}-[0-9]{2} 10:15:[4][0-9] DEBUG:', line) or \
               re.search(r'^[0-9]{4}-[0-9]{2}-[0-9]{2} 10:15:50 DEBUG:', line):
                yield line

if __name__ == '__main__':
    log_filename = 'log.txt'
    output_filename = 'new_loge.txt'  # Новое имя файла

    with open(output_filename, 'w', encoding='utf-8') as output_file:
        for line in process_log_file(log_filename):
            output_file.write(line)
```
